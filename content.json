{"meta":{"title":"Hexo-blog","subtitle":"rx-ted's blog","description":"Record the crip","author":"rx-ted","url":"https://rx-ted.github.io/blog","root":"/blog/"},"pages":[{"title":"关于","date":"2023-02-15T13:47:21.000Z","updated":"2023-12-10T06:10:39.617Z","comments":true,"path":"about.html","permalink":"https://rx-ted.github.io/blog/about.html","excerpt":"","text":"02 年出生，为热爱战斗着，努力学着变得勇敢 我是谁我是一位犹如咸鱼的普通人！ 作品 待写 其他欢迎您，来到我的个人博客，你，我生命中一个重要的过客，我们之所以是过客，因为你未曾会为我停留。"},{"title":"文章归档","date":"2023-12-09T05:00:08.000Z","updated":"2023-12-10T06:11:39.781Z","comments":true,"path":"archive.html","permalink":"https://rx-ted.github.io/blog/archive.html","excerpt":"","text":""},{"title":"about","date":"2023-02-15T13:47:21.000Z","updated":"2023-12-10T05:48:00.828Z","comments":true,"path":"about/index.html","permalink":"https://rx-ted.github.io/blog/about/index.html","excerpt":"","text":"一位犹如咸鱼的普通人！ 欢迎您，来到我的个人博客，你，我生命中一个重要的过客，我们之所以是过客，因为你未曾会为我停留。"},{"title":"友情链接","date":"2023-05-24T01:28:11.000Z","updated":"2023-12-10T05:48:00.828Z","comments":true,"path":"link/index.html","permalink":"https://rx-ted.github.io/blog/link/index.html","excerpt":"","text":""},{"title":"tag","date":"2023-02-15T13:47:15.000Z","updated":"2023-12-10T05:48:00.828Z","comments":true,"path":"tag/index.html","permalink":"https://rx-ted.github.io/blog/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"DSC28034PNT-基于定时器和PWM输出三色灯","slug":"DSC28034PNT-基于定时器和PWM输出三色灯","date":"2023-07-31T13:25:43.000Z","updated":"2023-12-10T06:12:39.645Z","comments":true,"path":"/2023/07/31/DSC28034PNT-基于定时器和PWM输出三色灯/","permalink":"https://rx-ted.github.io/blog/2023/07/31/DSC28034PNT-%E5%9F%BA%E4%BA%8E%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8CPWM%E8%BE%93%E5%87%BA%E4%B8%89%E8%89%B2%E7%81%AF/","excerpt":"DSC28034PNT-基于定时器和PWM输出三色灯项目旨在利用DSC28034PNT嵌入式开发平台的强大功能，通过定时器和PWM技术实现对三色灯的精确控制，实现了三色灯的控制。该项目旨在通过控制不同的PWM占空比来调节三色灯的亮度，从而实现丰富多彩的灯光效果。本项目适用于工业控制、物联网和智能家居等领域，为用户提供灵活且高效的光照控制方案。","text":"DSC28034PNT-基于定时器和PWM输出三色灯概述DSC28034PNT-基于定时器和PWM输出三色灯项目旨在利用DSC28034PNT嵌入式开发平台的强大功能，通过定时器和PWM技术实现对三色灯的精确控制，实现了三色灯的控制。该项目旨在通过控制不同的PWM占空比来调节三色灯的亮度，从而实现丰富多彩的灯光效果。本项目适用于工业控制、物联网和智能家居等领域，为用户提供灵活且高效的光照控制方案。本项目具有灵活性和高性能，适用于各种应用场景，如工业控制、物联网和智能家居。 可惜没有pwm灯光我由于时间不够，赶紧简单写个程序，简单测试三色灯效果。若有兴趣深入可以研究哈123 软件调试在软件调试阶段，首先需要编写适配DSC28034PNT的控制程序。通过设置定时器的频率和周期，以及不同颜色灯的PWM占空比，可以实现三色灯的亮度控制。在编写代码的过程中，需要注意定时器的配置和中断处理函数的编写，确保定时器能够精确地产生PWM信号。调试过程中需要使用调试工具监视变量和时序，以确保程序的正确性和稳定性。 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;dsc_config.h&quot;#include &lt;syscalls.h&gt;#include &quot;IQmathLib.h&quot;#define led0 GpioDataRegs.GPADAT.bit.GPIO7#define led1 GpioDataRegs.GPADAT.bit.GPIO8#define led2 GpioDataRegs.GPADAT.bit.GPIO9uint16_t IntCount = 0;INTERRUPT void timer0_isr(void);void delay(int second);void softPwmWrite(Uint32 pin, int brightness);void InitLED(void) &#123; EALLOW;// GpioCtrlRegs.GPBMUX1.bit.GPIO44 = 0; /* 普通IO,对应D402，LED灯 */// GpioCtrlRegs.GPBDIR.bit.GPIO44 = 1; /* 输出IO */ // led303 GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 0; GpioCtrlRegs.GPADIR.bit.GPIO7 = 1; GpioCtrlRegs.GPAQSEL1.bit.GPIO7 = 1; GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 0; GpioCtrlRegs.GPADIR.bit.GPIO8 = 1; GpioCtrlRegs.GPAQSEL1.bit.GPIO8 = 1; GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 0; GpioCtrlRegs.GPADIR.bit.GPIO9 = 1; GpioCtrlRegs.GPAQSEL1.bit.GPIO9 = 1; EDIS;&#125;void InitTimer() &#123; DINT; // 关闭CPU中断 InitPieCtrl(); //关闭清除CPU中断标记位 IER = 0X0000; IFR = 0X0000;// 初始化中断向量表 InitPieVectTable(); EALLOW;// 配置中断向量表 PieVectTable.TINT0 = &amp;timer0_isr; EDIS; EALLOW; //初始化模块 CpuTimer0Regs.TCR.bit.TSS = 1; CpuTimer0Regs.PRD.all = 120000; CpuTimer0Regs.TCR.bit.TIF = 1; CpuTimer0Regs.TCR.bit.TRB = 1; CpuTimer0Regs.TCR.bit.TIE = 1; CpuTimer0Regs.TCR.bit.TSS = 0; EDIS;//使能CPU中断 IER |= M_INT1;// 使能pie中断 PieCtrlRegs.PIEIER1.bit.INTx7 = 1; EINT; ERTM;&#125;int main(void) &#123; InitFlash(); InitSysCtrl(); //Initializes the System Control registers to a known state. InitLED(); InitTimer(); while (1) &#123; for (int i = 0; i &lt; 256; i++) &#123; if (i &lt; 20) &#123; led0 = 1; &#125; else &#123; led0 = 0; &#125; delay(10); // 控制PWM周期，可根据需要调整延时时间 &#125; for (int i = 0; i &lt; 256; i++) &#123; if (i &lt; 100) &#123; led1 = 1; &#125; else &#123; led1 = 0; &#125; delay(10); // 控制PWM周期，可根据需要调整延时时间 &#125; for (int i = 0; i &lt; 256; i++) &#123; if (i &lt; 200) &#123; led2 = 1; &#125; else &#123; led2 = 0; &#125; delay(10); // 控制PWM周期，可根据需要调整延时时间 &#125; &#125; return 0;&#125;//void CODE_SECTION(&quot;ramfuncs&quot;) //有无没区别void INTERRUPT timer0_isr() &#123; IntCount++;// GpioDataRegs.GPBTOGGLE.bit.GPIO43 = 1; PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;&#125;void delay(int second) &#123; int start = IntCount; while (IntCount - start &lt; second) ;&#125;// ---------------------------------------------------------------------------- 硬件接入在硬件接入阶段，需要将DSC28034PNT与三色灯电路进行连接。首先，将三色灯的R、G、B引脚分别连接到DSC28034PNT的PWM输出引脚，以便控制其亮度。然后，根据实际需求，将定时器的时钟源、频率和周期配置为合适的值，以产生适当的PWM信号。同时，还需注意电源和接地的连接，确保系统稳定可靠。1 总结通过软件调试和硬件接入，我们可以实现DSC28034PNT基于定时器和PWM输出三色灯的控制。该项目不仅为用户提供了一个简单易用的光照控制方案，还展示了DSC28034PNT在嵌入式应用中的高性能和灵活性。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"DSC28034PNT-搭建环境推荐以usart串口烧录下载","slug":"DSC28034PNT-搭建环境推荐以usart串口烧录下载","date":"2023-07-31T13:25:43.000Z","updated":"2023-12-10T06:12:39.857Z","comments":true,"path":"/2023/07/31/DSC28034PNT-搭建环境推荐以usart串口烧录下载/","permalink":"https://rx-ted.github.io/blog/2023/07/31/DSC28034PNT-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E6%8E%A8%E8%8D%90%E4%BB%A5usart%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95%E4%B8%8B%E8%BD%BD/","excerpt":"DSC28034PNT","text":"DSC28034PNT-搭建环境推荐以usart串口烧录下载DSC28034PNT作为一款高性能嵌入式开发平台，广泛应用于各种领域。在开发过程中，一个高效稳定的烧录下载环境至关重要。本报告将介绍以USART串口烧录下载的方式搭建DSC28034PNT开发环境的方法和优势。 摘要DSC28034PNT是一款强大的嵌入式开发平台，广泛应用于工业控制、物联网和智能家居等领域。为了实现高效的开发和调试，本报告推荐使用USART串口烧录下载的方法来搭建DSC28034PNT开发环境。通过该方法，可以实现简单快速的程序下载，提高开发效率，同时兼顾稳定性和灵活性。条件不够好的话，那就推荐用usart串口烧录下载。 USART串口烧录下载的原理和优势 USART串口烧录下载是一种通过串口通信实现程序下载的方法。在DSC28034PNT上，USART接口与计算机之间进行通信，将编译好的程序文件传输到开发板上，实现程序下载。该方法具有以下优势： 简单快速：USART串口烧录下载是一种简单快速的下载方式，不需要额外的下载器或调试器。只需通过串口连接开发板和计算机，即可完成下载过程。 稳定可靠：USART串口烧录下载具有稳定可靠的特性，传输过程中数据校验和错误处理能力保证了下载的准确性和可靠性。 灵活性强：USART串口烧录下载适用于不同操作系统和开发环境，具有较好的兼容性。同时，不受地域限制，可在各种场景下灵活应用。 搭建环境步骤以下是搭建DSC28034PNT开发环境以USART串口烧录下载为主要方式的步骤 准备软件：有官方提供的烧录下载器。 准备硬件：首先需要准备好一台计算机和DSC28034PNT开发板。确保计算机上已安装串口通信软件，如串口调试软件等，只要能接通串口即可，不限制什么软件。 连接硬件：将计算机的串口接口rxd txd 与DSC28034PNT的USART接口相连，确保连接牢固。 配置串口：打开计算机上的串口通信软件，选择正确的串口号和波特率，与DSC28034PNT上的USART配置一致。比如开发板上是115200，那么电脑上面也是115200 编译程序：使用相应的开发环境，编写并编译好需要下载的程序，生成程序文件。 下载程序：在串口通信软件中选择“发送文件”或类似选项，将编译好的程序文件传输到DSC28034PNT上，即可完成下载。 总结通过本报告的介绍，我们了解了以USART串口烧录下载的方式搭建DSC28034PNT开发环境的原理和优势。USART串口烧录下载具有简单快速、稳定可靠和灵活性强等特点，为DSC28034PNT开发提供了高效的解决方案。通过正确连接硬件，配置串口和正确下载程序，我们可以轻松地搭建一个稳定可靠的开发环境，并进行高效的开发和调试工作。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"时间显示 基于ssd1306 I2C 调用开源库 事半功倍","slug":"时间显示-基于ssd1306 I2C 调用开源库 事半功倍","date":"2023-07-31T13:25:43.000Z","updated":"2023-12-10T06:12:41.021Z","comments":true,"path":"/2023/07/31/时间显示-基于ssd1306 I2C 调用开源库 事半功倍/","permalink":"https://rx-ted.github.io/blog/2023/07/31/%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA-%E5%9F%BA%E4%BA%8Essd1306%20I2C%20%E8%B0%83%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%20%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D/","excerpt":"ESP32","text":"时间显示 基于ssd1306 I2C 调用开源库 事半功倍简介FireBeetle 2 ESP32-S3可以使用Arduino IDE、ESP-IDF、MicroPython进行编程，C语言、python都可以轻松的操纵硬件。我选择以vscode为主，插件platformio，需要安装python3.Purple Pi开发板通过J12排针提供了丰富的GPIO接口，包括UART、SPI、I2C、GPIO等（还包括DC5V、DC3.3V、GND）。 引脚概述 GPIO：常规引脚 Analog：模拟输入引脚 ADC：模数转换 TOUCH：触摸引脚 SPI：SPI接口 I2C：I2C接口 UART：UART接口 USB：USB接口 JTAG：调试接口 3V3：3.3V稳压电源输出 VCC：电源输入&#x2F;输出 输入：5V DC输入为FireBeetle供电（无法为锂电池充电） 输出：5V-USB 供电时输出USB电压，3.7V-锂电池供电时输出锂电池电压 GND：公共地引脚 引脚示意图 这次连接ssd1306 对应关系： board ssd1306 3V3 VDD GND GND IO2&#x2F;SCL SCK IO1&#x2F;SDA SDA 克隆开源库1234567891011121314151617# 新建一个项目 命名为01SHOWTIME，如~/1SHOWTIMEmkdir ~/01SHOWTIMEcd ~/01SHOWTIME# 新建platformio.ini 追加一些必要参数[env:dfrobot_firebeetle2_esp32s3] &gt;&gt; platformio.ini platform = espressif32 &gt;&gt; platformio.ini board = dfrobot_firebeetle2_esp32s3 &gt;&gt; platformio.ini framework = arduino &gt;&gt; platformio.ini lib_deps = / thingpulse/ESP8266 and ESP32 OLED driver for SSD1306 displays@^4.4.0 / paulstoffregen/Time@^1.6.1 &gt;&gt; platformio.ini # 配置platformio环境好了 只需要几个就行了pio check # 检查一些依赖文件，并补充完整# 复制一些例子到项目中，如下命令：cp &quot;.pio/libdeps/dfrobot_firebeetle2_esp32s3/ESP8266 and ESP32 OLED driver for SSD1306 displays/examples/SSD1306ClockDemo/images.h&quot; ./srccp &quot;.pio/libdeps/dfrobot_firebeetle2_esp32s3/ESP8266 and ESP32 OLED driver for SSD1306 displays/examples/SSD1306ClockDemo/SSD1306ClockDemo.ino&quot; ./src/main.c # 需要换名字由ino后缀改为main.cpio run # 就这样烧录到开发板上面，你说简不简单不 下载工具并编译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&gt; ~/.platformio/penv/Scripts/platformio.exe run --target upload Processing dfrobot_firebeetle2_esp32s3 (platform: espressif32; board: dfrobot_firebeetle2_esp32s3; framework: arduino)-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Tool Manager: Installing platformio/tool-mkspiffs @ ~2.230.0Downloading [####################################] 100%Unpacking [####################################] 100%Tool Manager: tool-mkspiffs@2.230.0 has been installed!Tool Manager: Installing platformio/tool-mklittlefs @ ~1.203.0Downloading [####################################] 100%Unpacking [####################################] 100%Tool Manager: tool-mklittlefs@1.203.210628 has been installed!Tool Manager: Installing platformio/tool-mkfatfs @ ~2.0.0Downloading [####################################] 100%Unpacking [####################################] 100%Tool Manager: tool-mkfatfs@2.0.1 has been installed!Verbose mode can be enabled via `-v, --verbose` optionCONFIGURATION: https://docs.platformio.org/page/boards/espressif32/dfrobot_firebeetle2_esp32s3.htmlPLATFORM: Espressif 32 (6.3.2) &gt; DFRobot Firebeetle 2 ESP32-S3HARDWARE: ESP32S3 240MHz, 320KB RAM, 4MB FlashDEBUG: Current (cmsis-dap) External (cmsis-dap, esp-bridge, esp-builtin, esp-prog, iot-bus-jtag, jlink, minimodule, olimex-arm-usb-ocd, olimex-arm-usb-ocd-h, olimex-arm-usb-tiny-h, olimex-jtag-tiny, tumpa)PACKAGES: - framework-arduinoespressif32 @ 3.20009.0 (2.0.9) - tool-esptoolpy @ 1.40501.0 (4.5.1) - tool-mkfatfs @ 2.0.1 - tool-mklittlefs @ 1.203.210628 (2.3) - tool-mkspiffs @ 2.230.0 (2.30) - toolchain-riscv32-esp @ 8.4.0+2021r2-patch5 - toolchain-xtensa-esp32s3 @ 8.4.0+2021r2-patch5LDF: Library Dependency Finder -&gt; https://bit.ly/configure-pio-ldfLDF Modes: Finder ~ chain, Compatibility ~ softFound 35 compatible librariesScanning dependencies...Dependency Graph|-- ESP8266 and ESP32 OLED driver for SSD1306 displays @ 4.4.0|-- Time @ 1.6.1|-- Wire @ 2.0.0Building in release modeCompiling .pio/build/dfrobot_firebeetle2_esp32s3/src/main.cpp.oBuilding .pio/build/dfrobot_firebeetle2_esp32s3/bootloader.binGenerating partitions .pio/build/dfrobot_firebeetle2_esp32s3/partitions.binesptool.py v4.5.1Creating esp32s3 image...Merged 1 ELF sectionSuccessfully created esp32s3 image.Compiling .pio/build/dfrobot_firebeetle2_esp32s3/libec9/Wire/Wire.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/lib071/ESP8266 and ESP32 OLED driver for SSD1306 displays/OLEDDisplay.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/lib071/ESP8266 and ESP32 OLED driver for SSD1306 displays/OLEDDisplayUi.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/lib9f8/Time/DateStrings.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/lib9f8/Time/Time.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/Esp.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/FirmwareMSC.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/FunctionalInterrupt.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/HWCDC.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/HardwareSerial.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/IPAddress.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/IPv6Address.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/MD5Builder.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/Print.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/Stream.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/StreamString.cpp.oArchiving .pio/build/dfrobot_firebeetle2_esp32s3/libec9/libWire.aCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/Tone.cpp.oIndexing .pio/build/dfrobot_firebeetle2_esp32s3/libec9/libWire.aCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/USB.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/USBCDC.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/USBMSC.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/WMath.cpp.oArchiving .pio/build/dfrobot_firebeetle2_esp32s3/lib9f8/libTime.aIndexing .pio/build/dfrobot_firebeetle2_esp32s3/lib9f8/libTime.aCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/WString.cpp.oArchiving .pio/build/dfrobot_firebeetle2_esp32s3/lib071/libESP8266 and ESP32 OLED driver for SSD1306 displays.aIndexing .pio/build/dfrobot_firebeetle2_esp32s3/lib071/libESP8266 and ESP32 OLED driver for SSD1306 displays.aCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/base64.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/cbuf.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-adc.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-bt.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-cpu.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-dac.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-gpio.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-i2c-slave.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-i2c.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-ledc.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-matrix.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-misc.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-psram.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-rgb-led.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-rmt.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-sigmadelta.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-spi.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-time.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-timer.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-tinyusb.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-touch.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/esp32-hal-uart.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/firmware_msc_fat.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/libb64/cdecode.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/libb64/cencode.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/main.cpp.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/stdlib_noniso.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/wiring_pulse.c.oCompiling .pio/build/dfrobot_firebeetle2_esp32s3/FrameworkArduino/wiring_shift.c.oArchiving .pio/build/dfrobot_firebeetle2_esp32s3/libFrameworkArduino.aIndexing .pio/build/dfrobot_firebeetle2_esp32s3/libFrameworkArduino.aLinking .pio/build/dfrobot_firebeetle2_esp32s3/firmware.elfRetrieving maximum program size .pio/build/dfrobot_firebeetle2_esp32s3/firmware.elfChecking size .pio/build/dfrobot_firebeetle2_esp32s3/firmware.elfAdvanced Memory Usage is available via &quot;PlatformIO Home &gt; Project Inspect&quot;RAM: [= ] 6.1% (used 20136 bytes from 327680 bytes)Flash: [== ] 23.4% (used 307341 bytes from 1310720 bytes)Building .pio/build/dfrobot_firebeetle2_esp32s3/firmware.binesptool.py v4.5.1Creating esp32s3 image...Merged 2 ELF sectionsSuccessfully created esp32s3 image.Configuring upload protocol...AVAILABLE: cmsis-dap, esp-bridge, esp-builtin, esp-prog, espota, esptool, iot-bus-jtag, jlink, minimodule, olimex-arm-usb-ocd, olimex-arm-usb-ocd-h, olimex-arm-usb-tiny-h, olimex-jtag-tiny, tumpaCURRENT: upload_protocol = esptoolLooking for upload port...Auto-detected: COM6Uploading .pio/build/dfrobot_firebeetle2_esp32s3/firmware.binesptool.py v4.5.1Serial port COM6Connecting...Chip is ESP32-S3 (revision v0.1)Features: WiFi, BLECrystal is 40MHzMAC: 34:85:18:41:90:98Uploading stub...Running stub...Stub running...Changing baud rate to 460800Changed.Configuring flash size...Flash will be erased from 0x00000000 to 0x00003fff...Flash will be erased from 0x00008000 to 0x00008fff...Flash will be erased from 0x0000e000 to 0x0000ffff...Flash will be erased from 0x00010000 to 0x0005bfff...Compressed 15040 bytes to 10331...Writing at 0x00000000... (100 %)Wrote 15040 bytes (10331 compressed) at 0x00000000 in 0.2 seconds (effective 526.4 kbit/s)...Hash of data verified.Compressed 3072 bytes to 146...Writing at 0x00008000... (100 %)Wrote 3072 bytes (146 compressed) at 0x00008000 in 0.1 seconds (effective 355.6 kbit/s)...Hash of data verified.Compressed 8192 bytes to 47...Writing at 0x0000e000... (100 %)Wrote 8192 bytes (47 compressed) at 0x0000e000 in 0.1 seconds (effective 641.7 kbit/s)...Hash of data verified.Compressed 307712 bytes to 170902...Writing at 0x00010000... (9 %)Writing at 0x0001b817... (18 %)Writing at 0x00027413... (27 %)Writing at 0x0002c8f6... (36 %)Writing at 0x000325fb... (45 %)Writing at 0x00037d21... (54 %)Writing at 0x0003d326... (63 %)Writing at 0x0004298d... (72 %)Writing at 0x00047f49... (81 %)Writing at 0x00050633... (90 %)Writing at 0x000589c7... (100 %)Wrote 307712 bytes (170902 compressed) at 0x00010000 in 2.1 seconds (effective 1157.4 kbit/s)...Hash of data verified.Leaving...Hard resetting via RTS pin...==================================================================================== [SUCCESS] Took 83.34 seconds ==================================================================================== 演示","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"DSC28034PNT-开箱并点亮LED","slug":"DSC28034PNT-开箱并点亮LED","date":"2023-07-29T07:19:38.000Z","updated":"2023-12-10T06:12:39.777Z","comments":true,"path":"/2023/07/29/DSC28034PNT-开箱并点亮LED/","permalink":"https://rx-ted.github.io/blog/2023/07/29/DSC28034PNT-%E5%BC%80%E7%AE%B1%E5%B9%B6%E7%82%B9%E4%BA%AELED/","excerpt":"DSC28034PNT-开箱并点亮LED","text":"DSC28034PNT-开箱并点亮LED开箱DSC28034PNT 结合了数字信号处理器 (DSP) 和微控制器 (MCU) 的特点，旨在提供高性能的实时信号处理和控制功能。 DSC28034PNT 集成了一个高性能的32位DSP内核，以及丰富的外设接口，如模拟输入输出、通信接口（UART、SPI、I2C等）、定时器等，使其适用于各种工业控制、汽车电子、通信设备和消费类电子产品等领域。 该芯片的特点包括：高性能：搭载高性能的DSP内核，可以高效地进行实时信号处理和算法运算。低功耗：采用先进的功耗管理技术，以最小化功耗，延长电池寿命或节约能源。丰富的外设接口：支持多种通信接口和外围设备连接，满足不同应用的需求。可靠性和稳定性：经过严格的测试和验证，保证稳定可靠的工作。总的来说，DSC28034PNT 是一款功能强大、性能优越的数字信号控制器芯片，适用于各种实时信号处理和控制应用，为开发者提供了一个高效、可靠的解决方案。 开发板DSC28034PNT的设计美观简洁，让人一目了然地理解其工作原理。其精致的外观和直观的接口设计，使得使用者能够轻松掌握开发板的特性与功能。不仅如此，DSC28034PNT还提供了丰富的文档和示例代码，帮助用户更快上手，快速实现各种应用。这种用户友好的设计，让我对该开发板的质量和性能深感赞赏。 看图： 下面为开发板，上面为调试器 可以访问官网 项目1、概述本项目旨在使用TMS320F28034芯片控制LED灯的点亮，展示28034作为微控制器的基本功能。通过该项目，将了解如何在28034上配置GPIO引脚，并使用GPIO控制LED灯的点亮和熄灭。 2、软件调试 配置开发环境：下载并安装官方提供的开发环境（IDE）。 创建工程：在IDE中创建一个新的工程，并选择28034芯片作为目标。 配置GPIO：在工程中配置GPIO引脚作为输出，用于连接LED灯。 编写代码：编写控制LED灯点亮和熄灭的C代码，并将其加载到芯片中。 调试代码：使用调试功能检查代码是否正确，是否能够正确地控制LED灯的状态。 3、硬件接入准备硬件：将28034芯片焊接到PCB板上，并连接好相应的外部电路。连接LED灯：将LED灯连接到配置好的GPIO引脚上。配置电源：为28034提供稳定的电源供电，确保工作电压符合芯片规格。 确保电路连接正确，特别是GPIO引脚的连接和电源供电。 总结通过完成这个项目，您将能够掌握28034的GPIO配置和使用，了解硬件与软件的配合，同时完成一个简单的LED点亮控制项目。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"【Milk-V Duo 开发板免费体验】Linux下i2c驱动OLED ssd1306","slug":"milkv-duo-i2c-ssd1306","date":"2023-07-18T09:45:19.000Z","updated":"2023-12-10T06:12:40.361Z","comments":true,"path":"/2023/07/18/milkv-duo-i2c-ssd1306/","permalink":"https://rx-ted.github.io/blog/2023/07/18/milkv-duo-i2c-ssd1306/","excerpt":"","text":"Linux下i2c驱动OLED ssd1306参数 ssd1306 128*32 0x3c i2c0 dts修改1234567891011// build/boards/cv180x/cv1800b_milkv_duo_sd/dts_riscv/cv1800b_milkv_duo_sd.dts // 速率 名称 地址，随便修改，一旦有新的设备地址，可以在i2c0下追加新设备&amp;i2c0 &#123; status = &quot;okay&quot;; ssd1306:ssd1306@3c &#123; compatible = &quot;oled12832,ssd1306&quot;; reg = &lt;0x3c&gt;; &#125;;&#125;; 编译修改好了dts设备树，需要重新编译，见教程：传送最后得到image镜像，在milkv-duo上烧录即可。 1234i2cdetect -yr 0 # 可以看到0x3c位置# 等到导入KO文件，就变成UU，表示成功 源代码获取KO文件在sdk下新建driver，然后再新建ssd1306文件夹，接着新文件命名为ssd1306.c，不想分头文件借鉴某位大佬源代码，稍微修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kdev_t.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/stat.h&gt;#include &lt;linux/uaccess.h&gt;/* 全局静态变量：希望全局变量仅限于在本源文件中使用，在其他源文件中不能引用，也就是说限制其作用域只在 定义该变量的源文件内有效，而在同一源程序的其他源文件中不能使用 */#define OK (0)#define ERROR (-1)/* I2C设备驱动 */static struct i2c_driver oled_driver;/* I2C从设备 */static struct i2c_client *oled_client;/* i2c设备地址 */static unsigned short addr = 0x3C;/* i2c驱动需要探测的从设备地址 */static unsigned short address_list[] = &#123;0x3c, 0xfffeU&#125;; // 0xfffeU 结束标志/* 设备编号 */static dev_t devid;/* 设备class */static struct class *oled_class;/* oled字符设备哦 */static struct cdev i2c_cdev;/***************************************************************************************************** * * 从ASCII0x20开始 取模方向：逐列式 每列1个字节，共6列 即一个字节占8行6列 * 取模走向：低位在前 * *****************************************************************************************************/static const u8 ASCII6x8[][6] = &#123; &#123;0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;, // sp ASCII 0x20 &#123;0x00, 0x00, 0x00, 0x2f, 0x00, 0x00&#125;, // ! &#123;0x00, 0x00, 0x07, 0x00, 0x07, 0x00&#125;, // &quot; &#123;0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14&#125;, // # &#123;0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12&#125;, // $ &#123;0x00, 0x62, 0x64, 0x08, 0x13, 0x23&#125;, // % &#123;0x00, 0x36, 0x49, 0x55, 0x22, 0x50&#125;, // &amp; &#123;0x00, 0x00, 0x05, 0x03, 0x00, 0x00&#125;, // &#x27; &#123;0x00, 0x00, 0x1c, 0x22, 0x41, 0x00&#125;, // ( &#123;0x00, 0x00, 0x41, 0x22, 0x1c, 0x00&#125;, // ) &#123;0x00, 0x14, 0x08, 0x3E, 0x08, 0x14&#125;, // * &#123;0x00, 0x08, 0x08, 0x3E, 0x08, 0x08&#125;, // + &#123;0x00, 0x00, 0x00, 0xA0, 0x60, 0x00&#125;, // , &#123;0x00, 0x08, 0x08, 0x08, 0x08, 0x08&#125;, // - &#123;0x00, 0x00, 0x60, 0x60, 0x00, 0x00&#125;, // . &#123;0x00, 0x20, 0x10, 0x08, 0x04, 0x02&#125;, // / &#123;0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E&#125;, // 0 &#123;0x00, 0x00, 0x42, 0x7F, 0x40, 0x00&#125;, // 1 &#123;0x00, 0x42, 0x61, 0x51, 0x49, 0x46&#125;, // 2 &#123;0x00, 0x21, 0x41, 0x45, 0x4B, 0x31&#125;, // 3 &#123;0x00, 0x18, 0x14, 0x12, 0x7F, 0x10&#125;, // 4 &#123;0x00, 0x27, 0x45, 0x45, 0x45, 0x39&#125;, // 5 &#123;0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30&#125;, // 6 &#123;0x00, 0x01, 0x71, 0x09, 0x05, 0x03&#125;, // 7 &#123;0x00, 0x36, 0x49, 0x49, 0x49, 0x36&#125;, // 8 &#123;0x00, 0x06, 0x49, 0x49, 0x29, 0x1E&#125;, // 9 &#123;0x00, 0x00, 0x36, 0x36, 0x00, 0x00&#125;, // : &#123;0x00, 0x00, 0x56, 0x36, 0x00, 0x00&#125;, // ; &#123;0x00, 0x08, 0x14, 0x22, 0x41, 0x00&#125;, // &lt; &#123;0x00, 0x14, 0x14, 0x14, 0x14, 0x14&#125;, // = &#123;0x00, 0x00, 0x41, 0x22, 0x14, 0x08&#125;, // &gt; &#123;0x00, 0x02, 0x01, 0x51, 0x09, 0x06&#125;, // ? &#123;0x00, 0x32, 0x49, 0x59, 0x51, 0x3E&#125;, // @ &#123;0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C&#125;, // A &#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x36&#125;, // B &#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x22&#125;, // C &#123;0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C&#125;, // D &#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x41&#125;, // E &#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x01&#125;, // F &#123;0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A&#125;, // G &#123;0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F&#125;, // H &#123;0x00, 0x00, 0x41, 0x7F, 0x41, 0x00&#125;, // I &#123;0x00, 0x20, 0x40, 0x41, 0x3F, 0x01&#125;, // J &#123;0x00, 0x7F, 0x08, 0x14, 0x22, 0x41&#125;, // K &#123;0x00, 0x7F, 0x40, 0x40, 0x40, 0x40&#125;, // L &#123;0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F&#125;, // M &#123;0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F&#125;, // N &#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E&#125;, // O &#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x06&#125;, // P &#123;0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E&#125;, // Q &#123;0x00, 0x7F, 0x09, 0x19, 0x29, 0x46&#125;, // R &#123;0x00, 0x46, 0x49, 0x49, 0x49, 0x31&#125;, // S &#123;0x00, 0x01, 0x01, 0x7F, 0x01, 0x01&#125;, // T &#123;0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F&#125;, // U &#123;0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F&#125;, // V &#123;0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F&#125;, // W &#123;0x00, 0x63, 0x14, 0x08, 0x14, 0x63&#125;, // X &#123;0x00, 0x07, 0x08, 0x70, 0x08, 0x07&#125;, // Y &#123;0x00, 0x61, 0x51, 0x49, 0x45, 0x43&#125;, // Z &#123;0x00, 0x00, 0x7F, 0x41, 0x41, 0x00&#125;, // [ &#123;0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55&#125;, // 55 &#123;0x00, 0x00, 0x41, 0x41, 0x7F, 0x00&#125;, // ] &#123;0x00, 0x04, 0x02, 0x01, 0x02, 0x04&#125;, // ^ &#123;0x00, 0x40, 0x40, 0x40, 0x40, 0x40&#125;, // _ &#123;0x00, 0x00, 0x01, 0x02, 0x04, 0x00&#125;, // &#x27; &#123;0x00, 0x20, 0x54, 0x54, 0x54, 0x78&#125;, // a &#123;0x00, 0x7F, 0x48, 0x44, 0x44, 0x38&#125;, // b &#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x20&#125;, // c &#123;0x00, 0x38, 0x44, 0x44, 0x48, 0x7F&#125;, // d &#123;0x00, 0x38, 0x54, 0x54, 0x54, 0x18&#125;, // e &#123;0x00, 0x08, 0x7E, 0x09, 0x01, 0x02&#125;, // f &#123;0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C&#125;, // g &#123;0x00, 0x7F, 0x08, 0x04, 0x04, 0x78&#125;, // h &#123;0x00, 0x00, 0x44, 0x7D, 0x40, 0x00&#125;, // i &#123;0x00, 0x40, 0x80, 0x84, 0x7D, 0x00&#125;, // j &#123;0x00, 0x7F, 0x10, 0x28, 0x44, 0x00&#125;, // k &#123;0x00, 0x00, 0x41, 0x7F, 0x40, 0x00&#125;, // l &#123;0x00, 0x7C, 0x04, 0x18, 0x04, 0x78&#125;, // m &#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x78&#125;, // n &#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x38&#125;, // o &#123;0x00, 0xFC, 0x24, 0x24, 0x24, 0x18&#125;, // p &#123;0x00, 0x18, 0x24, 0x24, 0x18, 0xFC&#125;, // q &#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x08&#125;, // r &#123;0x00, 0x48, 0x54, 0x54, 0x54, 0x20&#125;, // s &#123;0x00, 0x04, 0x3F, 0x44, 0x40, 0x20&#125;, // t &#123;0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C&#125;, // u &#123;0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C&#125;, // v &#123;0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C&#125;, // w &#123;0x00, 0x44, 0x28, 0x10, 0x28, 0x44&#125;, // x &#123;0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C&#125;, // y &#123;0x00, 0x44, 0x64, 0x54, 0x4C, 0x44&#125;, // z &#123;0x14, 0x14, 0x14, 0x14, 0x14, 0x14&#125; // horiz lines&#125;;/************************************************************* * * Function : 通过SPI协议写命令 * Input : data 数据 * Return : 写入字节长度 负数写入失败 * **************************************************************/static int oled_write_cmd(unsigned char cmd)&#123; struct i2c_msg msg[1]; unsigned char cmds[2]; cmds[0] = 0x00; cmds[1] = cmd; /* 数据传输三要素：源，目的，长度 */ msg[0].addr = oled_client-&gt;addr; /* 目的 */ msg[0].buf = cmds; /* 源 */ msg[0].len = 2; /* 长度为字节 = 数据 + 地址 */ msg[0].flags = 0; /* 0表示写 */ if (i2c_transfer(oled_client-&gt;adapter, msg, 1) == 1) return 2; else return ERROR;&#125;/************************************************************* * * Function : 通过SPI协议写数据 * Input : data 数据 * Return : 写入字节长度 负数写入失败 * **************************************************************/static int oled_write_data(unsigned char data)&#123; struct i2c_msg msg[1]; unsigned char datas[2]; datas[0] = 0x40; datas[1] = data; /* 数据传输三要素：源，目的，长度 */ msg[0].addr = oled_client-&gt;addr; /* 目的 */ msg[0].buf = datas; /* 源 */ msg[0].len = 2; /* 长度为2字节 = 数据 + 地址 */ msg[0].flags = 0; /* 0表示写 */ if (i2c_transfer(oled_client-&gt;adapter, msg, 1) == 1) return 2; else return ERROR;&#125;/************************************************************* * * Function : 坐标设定 * Input : x x坐标 0x00~0x7F * y y坐标 0~7 * **************************************************************/static void oled_pos(u8 x, u8 y)&#123; oled_write_cmd(0xB0 + y); oled_write_cmd(((x &amp; 0xF0) &gt;&gt; 4) | 0x10); /* 设置列地址高四位 */ oled_write_cmd(x &amp; 0x0F); /* 设置列地址低四位 */&#125;/************************************************************* * * Function : 清屏 * **************************************************************/static void oled_clear(void)&#123; u8 x; u8 y; for (y = 0; y &lt; 8; y++) &#123; oled_write_cmd(0xB0 + y); /* 选择页 */ oled_write_cmd(0x00); /* 设置列地址低四位 */ oled_write_cmd(0x10); /* 设置列地址高四位 */ for (x = 0; x &lt; 0x80; x++) oled_write_data(0x00); /* 每次清1列 */ &#125;&#125;/*************************************************************************************************** * * Function : 写入一组标准ASCII字符串 一个字节占8行6列 * Input : x 设置列地址0~0X7F * y 设置页地址0~7 * str 要显示的字符 * **************************************************************************************************/static void oled_p6x8str(u8 x, u8 y, u8 *str)&#123; u8 i = 0; u8 j = 0; u8 k = 0; while (str[j] != &#x27;\\0&#x27;) &#123; while ((str[j] &lt; 0x20) || (str[j] &gt; 0x80)) /* 当写入的没有对应的点阵时 显示空格 */ str[j] = 32; k = str[j] - 32; if (x &gt; 121) &#123; x = 0; y++; &#125; oled_pos(x, y); /* 选中坐标 */ for (i = 0; i &lt; 6; i++) oled_write_data(ASCII6x8[k][i]); /* 写入一个字节 */ x += 6; j++; &#125;&#125;/******** * oled init */static int oledinit(void)&#123; oled_write_cmd(0xAE); /* 显示关 */ oled_write_cmd(0x40); /* 设置列低位地址 */ oled_write_cmd(0xB0); /* 设置列高位地址 */ oled_write_cmd(0xC8); oled_write_cmd(0x81); oled_write_cmd(0xFF); oled_write_cmd(0xA1); oled_write_cmd(0xA6); oled_write_cmd(0xA8); oled_write_cmd(0x1F); oled_write_cmd(0xD3); oled_write_cmd(0x00); oled_write_cmd(0xD5); oled_write_cmd(0xF0); oled_write_cmd(0xD9); oled_write_cmd(0x22); oled_write_cmd(0xDA); oled_write_cmd(0x02); oled_write_cmd(0xDB); oled_write_cmd(0x49); oled_write_cmd(0x8D); oled_write_cmd(0x14); oled_write_cmd(0xAF); return 0;&#125;/*************************************************************************************************** * * 打开设备 * **************************************************************************************************/static int oled_open(struct inode *inode, struct file *filp)&#123; // oled_write_cmd(0xAE); /* 显示关 */ // oled_write_cmd(0x00); /* 设置列低位地址 */ // oled_write_cmd(0x10); /* 设置列高位地址 */ // oled_write_cmd(0x40); /* set start line address Set Mapping RAM Display Start Line (0x00~0x3F) */ // oled_write_cmd(0x81); /* 设置对比度 */ // oled_write_cmd(0xCF); /* 值越大 越亮 */ // oled_write_cmd(0xA1); /* 设置列左右反置 0xa0左右反置 0xa1正常 */ // oled_write_cmd(0xC8); /* 设置行上下反置 0xc0上下反置 0xc8正常 */ // oled_write_cmd(0xA6); /* 设置正常显示 */ // oled_write_cmd(0x20); /* 设置页地址模式 (0x00/0x01/0x02) */ // oled_write_cmd(0x02); /* 页寻址 */ // oled_write_cmd(0x8D); /* 设置电荷磊开关 */ // oled_write_cmd(0x14); /* 电荷磊开 */ // oled_write_cmd(0xA4); /* 字符显示开关 0xA4：开 0xA5：关 */ // oled_write_cmd(0xA6); /* 背景色显示开关 0xA6:关 0xA7:开 */ // oled_write_cmd(0xAF); /* 显示开 */ oledinit(); oled_clear(); /* 初始清屏 */ oled_pos(0, 0); printk(KERN_INFO &quot;oled open\\n&quot;); return 0;&#125;/*************************************************************************************************** * * Function: oled写函数 * Input : buffer 2个字节 第一个字节oled片内地址0~0xFF，第二个字节为要写入的数据 * size 写数据的长度 两个字节 * **************************************************************************************************/static ssize_t oled_write(struct file *filp, const char __user *buffer, size_t size, loff_t *off)&#123; // 一共可以显示168字 unsigned char data[168]; copy_from_user(data, buffer, 168); oled_p6x8str(0, 0, data); return 0;&#125;/* * oled操作集 */static struct file_operations oled_fops = &#123; .owner = THIS_MODULE, .write = oled_write, .open = oled_open,&#125;;/* * 当驱动和设备信息匹配成功之后，就会调用probe函数，驱动所有的资源的注册和初始化全部放在probe函数中； */static int oled_probe(struct i2c_client *client, const struct i2c_device_id *i2c_device)&#123; int result; /* 动态分配字符设备编号: (major,0) */ if (alloc_chrdev_region(&amp;devid, 0, 1, &quot;oled&quot;) == OK) &#123; printk(KERN_INFO &quot;alloc device number : major:[%d], minor:[%d] succeed!\\n&quot;, MAJOR(devid), MINOR(devid)); &#125; else &#123; printk(KERN_INFO &quot;register device number error!\\n&quot;); return ERROR; &#125; /* 字符设备初始化以及注册 */ cdev_init(&amp;i2c_cdev, &amp;oled_fops); cdev_add(&amp;i2c_cdev, devid, 1); /* 创建类,它会在sys目录下创建/sys/class/oled_class这个类 */ oled_class = class_create(THIS_MODULE, &quot;oled_class&quot;); if (IS_ERR(oled_class)) &#123; printk(&quot;can&#x27;t create class\\n&quot;); return ERROR; &#125; /* 在/sys/class/oled_class下创建oled设备，然后mdev通过这个自动创建/dev/oled这个设备节点 */ device_create(oled_class, NULL, devid, NULL, &quot;oled&quot;); printk(KERN_INFO &quot;create device file &#x27;oled&#x27; succeed!\\n&quot;); /* 保存当前i2c_client */ oled_client = client; printk(KERN_INFO &quot;get i2c_client, client name = %s, addr = 0x%x\\n&quot;, oled_client-&gt;name, oled_client-&gt;addr); printk(KERN_INFO &quot;get i2c_adapter, adapter name = %s\\n&quot;, oled_client-&gt;adapter-&gt;name); printk(KERN_INFO &quot;oled probe\\n&quot;); return 0;&#125;/* * 设备被移除了，或者驱动被卸载了，全部要释放，释放资源的操作就放在该函数中 */static int oled_remove(struct i2c_client *client)&#123; /* 注销类、以及类设备 /sys/class/oled_class会被移除*/ device_destroy(oled_class, devid); class_destroy(oled_class); /* 移除字符设备 */ cdev_del(&amp;i2c_cdev); /* 注销设备编号 */ unregister_chrdev_region(devid, 1); printk(KERN_INFO &quot;oled remove\\n&quot;); return 0;&#125;/* * oled设备探测到的回调函数 */static int oled_detect(struct i2c_client *client, struct i2c_board_info *info)&#123; printk(KERN_INFO &quot;oled detect success\\n&quot;); // 设置I2C从设备名称 必须要和i2c_driver.idtable里面名称匹配 strcpy(info-&gt;type, &quot;oled&quot;); return OK;&#125;/* i2c设备id列表 */static const struct i2c_device_id oled_id[] = &#123; &#123;&quot;ssd1306&quot;, 0&#125;, &#123;&#125; /* 最后一个必须为空,表示结束 */&#125;;/* * i2c驱动入口函数 */static struct i2c_driver oled_driver = &#123; .probe = oled_probe, .remove = oled_remove, .driver = &#123; .name = &quot;oled&quot;, /* 驱动名称 */ .owner = THIS_MODULE, &#125;, .address_list = address_list, /* 从设备列表 */ .detect = oled_detect, .id_table = oled_id, /* id列表 */ .class = I2C_CLASS_HWMON | I2C_CLASS_SPD, /* 内存设备 */&#125;;/* *init入口函数 */static int __init oled_init(void)&#123; i2c_add_driver(&amp;oled_driver); /* 将i2c_driver注册到系统中去 */ printk(KERN_INFO &quot;oled i2c_driver was added into the system.\\n&quot;); return 0;&#125;/* * exit出口函数 */static void __exit oled_exit(void)&#123; i2c_del_driver(&amp;oled_driver); printk(KERN_INFO &quot;oled i2c_driver was deleted from the system.\\n&quot;); return;&#125;module_init(oled_init);module_exit(oled_exit);MODULE_AUTHOR(&quot;rx-ted&quot;);MODULE_LICENSE(&quot;GPL&quot;);MODULE_DESCRIPTION(&quot;oled device driver, 2023-07-18&quot;); 再建立makefile，如 123456789101112131415SDK_DIR = ~/buildrootKERN_DIR = $(SDK_DIR)/linux_5.10/build/cv1800b_milkv_duo_sd# app:# $(CC) -o ssd1306-app ssd1306-app.call: make -C $(KERN_DIR) M=$(PWD) modulesclean: make -C $(KERN_DIR) M=$(PWD) modules clean rm -rf modules.orderobj-m += ssd1306.o 这样可以到一个ssd1306.ko文件 传送milkv-duo将ssd1306.ko传送milkv-duo 123scp driver/ssd1306/ssd1306.ko root@192.168.42.1:/mnt/system/ko 进入milkv-duo，这样命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 1. lsmod 先看看两个lsmod前后区别[root@milkv]~# lsmodModule Size Used by Tainted: GFcvi_vc_driver 879138 0 [permanent]cv180x_jpeg 25220 1 cvi_vc_driver,[permanent]cv180x_vcodec 28451 2 cvi_vc_driver,cv180x_jpeg,[permanent]cv180x_tpu 32041 0 [permanent]cv180x_clock_cooling 5953 0 [permanent]cv180x_thermal 3404 0cv180x_rgn 100809 0 [permanent]cv180x_dwa 48669 0 [permanent]cv180x_vpss 280938 0 [permanent]cv180x_vi 338826 0 [permanent]snsr_i2c 9341 0 [permanent]cvi_mipi_rx 54306 0 [permanent]cv180x_fast_image 32955 0 [permanent]cv180x_rtos_cmdqu 25922 1 cv180x_fast_image,[permanent]cv180x_base 96472 8 cvi_vc_driver,cv180x_rgn,cv180x_dwa,cv180x_vpss,cv180x_vi,snsr_i2c,cvi_mipi_rx,cv180x_rtos_cmdqu,[permanent]cv180x_sys 64161 7 cvi_vc_driver,cv180x_rgn,cv180x_dwa,cv180x_vpss,cv180x_vi,cv180x_fast_image,cv180x_base,[permanent]# 2. insmod /mnt/system/ko/ssd1306.ko[root@milkv]~# insmod /mnt/system/ko/ssd1306.ko# 3. lsmod[root@milkv]~# lsmodModule Size Used by Tainted: GFssd1306 5654 0cvi_vc_driver 879138 0 [permanent]cv180x_jpeg 25220 1 cvi_vc_driver,[permanent]cv180x_vcodec 28451 2 cvi_vc_driver,cv180x_jpeg,[permanent]cv180x_tpu 32041 0 [permanent]cv180x_clock_cooling 5953 0 [permanent]cv180x_thermal 3404 0cv180x_rgn 100809 0 [permanent]cv180x_dwa 48669 0 [permanent]cv180x_vpss 280938 0 [permanent]cv180x_vi 338826 0 [permanent]snsr_i2c 9341 0 [permanent]cvi_mipi_rx 54306 0 [permanent]cv180x_fast_image 32955 0 [permanent]cv180x_rtos_cmdqu 25922 1 cv180x_fast_image,[permanent]cv180x_base 96472 8 cvi_vc_driver,cv180x_rgn,cv180x_dwa,cv180x_vpss,cv180x_vi,snsr_i2c,cvi_mipi_rx,cv180x_rtos_cmdqu,[permanent]cv180x_sys 64161 7 cvi_vc_driver,cv180x_rgn,cv180x_dwa,cv180x_vpss,cv180x_vi,cv180x_fast_image,cv180x_base,[permanent]# 4. dmesg[root@milkv]~# dmesg[ 412.711906] create device file &#x27;oled&#x27; succeed![ 412.711920] get i2c_client, client name = ssd1306, addr = 0x3c[ 412.711927] get i2c_adapter, adapter name = Synopsys DesignWare I2C adapter[ 412.711933] oled probe[ 412.712132] oled i2c_driver was added into the system.# 打印 hello ssd1306[root@milkv]~# echo hello ssd1306 &gt; /dev/oled^C[root@milkv]~# echo 1234567890 qwertyuiopasdfghjklzxcvbnm &gt; /dev/oled^C 演示效果","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"【沁恒 CH32V208 开发板免费试用】RTT 模拟Arduino库开发项目","slug":"【沁恒-CH32V208-开发板免费试用】RTT-模拟Arduino库开发项目","date":"2023-05-24T12:16:10.000Z","updated":"2023-12-10T06:12:39.049Z","comments":true,"path":"/2023/05/24/【沁恒-CH32V208-开发板免费试用】RTT-模拟Arduino库开发项目/","permalink":"https://rx-ted.github.io/blog/2023/05/24/%E3%80%90%E6%B2%81%E6%81%92-CH32V208-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%E3%80%91RTT-%E6%A8%A1%E6%8B%9FArduino%E5%BA%93%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"本文将介绍如何使用RT-thread实时操作系统和Arduino库在沁恒 CH32V208开发板上进行开发。 概述沁恒 CH32V208是一款基于RISC-V内核的微控制器，支持RT-thread实时操作系统。本文将介绍如何使用RTT模拟Arduino库在沁恒 CH32V208开发板上进行开发，并提供一些示例代码。通过本文的介绍可以了解如何在沁恒 CH32V208上使用Arduino库进行开发，以及如何实现数字输入输出、模拟输入输出等功能。 原理在沁恒 CH32V208上使用Arduino库进行开发需要先安装RTT模拟Arduino库。RTT模拟Arduino库是一个基于RT-thread实时操作系统的Arduino库模拟器，可以在RT-thread上运行Arduino库中的函数和例程。 在使用RTT模拟Arduino库时，需要在应用程序中引入相应的头文件，并初始化Arduino库： 12345678910111213141516#include &lt;rtthread.h&gt;#include &lt;Arduino.h&gt;void setup(void) &#123; /* put your setup code here, to run once: */ pinMode(LED_BUILTIN, OUTPUT); &#125;void loop(void)&#123; /* put your main code here, to run repeatedly: */ digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); delay(100);&#125; 在上面的程序中，首先调用了rt_hw_board_init()函数来初始化硬件资源。然后，使用init()函数和setup()函数初始化Arduino库，并在loop()函数中实现LED闪烁功能。 除了数字输入输出外，RTT模拟Arduino库还支持模拟输入输出、串口通信、SPI通信等功能。以下是一些示例代码： 12345678910111213141516// 模拟输入输出analogWrite(9, 128);int val = analogRead(A0);// 串口通信Serial.begin(9600);Serial.println(&quot;Hello, world!&quot;);// SPI通信#include &lt;SPI.h&gt;SPISettings settings(1000000, MSBFIRST, SPI_MODE0);SPI.beginTransaction(settings);digitalWrite(SS, LOW);SPI.transfer(0x01);digitalWrite(SS, HIGH);SPI.endTransaction(); 代码： 完整的示例代码如下： 123456789101112131415161718192021222324252627#include &lt;rtthread.h&gt;#include &lt;Arduino.h&gt;void setup()&#123; pinMode(13, OUTPUT);&#125;void loop()&#123; digitalWrite(13, HIGH); delay(1000); digitalWrite(13, LOW); delay(1000);&#125;int main(void)&#123; rt_hw_board_init(); init(); setup(); while (1) &#123; loop(); &#125;&#125; 站在巨人的肩膀上，我们可以更快地前进。在开发过程中，我们应该不断学习和借鉴其他人的经验和技术，以便更好地解决问题和提高效率。同时，我们也应该分享自己的经验和技术，帮助其他人更好地成长和进步。只有这样，我们才能共同推动技术的发展和进步，创造更加美好的未来。","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"rt-thread移植","slug":"rt-thread移植","permalink":"https://rx-ted.github.io/blog/tags/rt-thread%E7%A7%BB%E6%A4%8D/"}]},{"title":"【沁恒-CH32V208-开发板免费试用】RTT 基于SSD1306显示的一些例子","slug":"【沁恒-CH32V208-开发板免费试用】RTT-基于SSD1306显示的一些例子","date":"2023-05-24T11:41:52.000Z","updated":"2023-12-10T06:12:38.849Z","comments":true,"path":"/2023/05/24/【沁恒-CH32V208-开发板免费试用】RTT-基于SSD1306显示的一些例子/","permalink":"https://rx-ted.github.io/blog/2023/05/24/%E3%80%90%E6%B2%81%E6%81%92-CH32V208-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%E3%80%91RTT-%E5%9F%BA%E4%BA%8ESSD1306%E6%98%BE%E7%A4%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90/","excerpt":"","text":"概述沁恒-CH32V208是一款基于risc-v内核的微控制器，支持RT-thread实时操作系统。本文将介绍如何使用SSD1306显示屏和U8G2库在RT-thread上进行开发，并提供一些示例代码。通过本文的介绍，读者可以了解如何在沁恒-CH32V208上使用SSD1306显示屏和U8G2库进行图形化界面开发，以及如何绘制矩形、圆形、位图等图形元素，以及如何滚动显示内容等。这些功能可以帮助开发者快速构建出具有良好用户体验的应用程序。大家若有兴趣可以继续深入研究哈。 环境&#x2F;工具需要借助一些软件和硬件相结合，做出项目. 软件 Windows10 (其他平台没测试) VScode make (针对makefile编译) risc-v 8.2.0 工具箱 (github有提供riscv-none-embed-XXX压缩包) WCHISPTOOLS (沁恒自带烧录工具) SERIAL DEBUG （查看调试日志） 原理让我们来了解一下沁恒-CH32V208上使用SSD1306显示屏和U8G2库进行开发的原理。 首先，SSD1306是一款128x32像素的OLED显示屏，具有高亮度、高对比度、低功耗等特点。在沁恒-CH32V208上使用SSD1306显示屏需要通过I2C总线进行通信，并使用U8G2库进行驱动。 U8G2库是一款轻量级的图形化界面库，支持多种显示屏类型和控制器，包括SSD1306、SH1106、ST7920等。在使用U8G2库时，需要根据显示屏类型和控制器类型选择相应的初始化函数，并设置相关参数，如I2C地址、SPI模式等。 在使用U8G2库绘制图形时，可以使用U8G2库提供的API函数，如u8g2_DrawFrame()函数绘制矩形、u8g2_DrawCircle()函数绘制圆形、u8g2_DrawXBM()函数显示位图等。同时，U8G2库还支持滚动显示、反转显示、旋转显示等功能，可以根据实际需求进行设置。 通过以上原理介绍，可以了解到在沁恒-CH32V208上使用SSD1306显示屏和U8G2库进行开发的基本原理和流程。 感谢 wuhanstudio 提供 rt-u8g2 开源库 测试基于github-&gt;01LED上复制到03SSD1306文件夹下，并新增一些内容，如下：在同一个文件夹下新建文件，命名为rt-u8g2/rt-u8g2.mk 12345678910PACKAGE_NAME := rt-u8g2CPPPATHS += -I$(APP_ROOT)/$(PACKAGE_NAME)/portCPPPATHS += -I$(APP_ROOT)/$(PACKAGE_NAME)/srcCPPPATHS += -I$(APP_ROOT)/$(PACKAGE_NAME)C_FILES += $(wildcard $(APP_ROOT)/$(PACKAGE_NAME)/src/*.c)C_FILES += $(wildcard $(APP_ROOT)/$(PACKAGE_NAME)/port/*.c)# 对应你的ssd1306型号# C_FILES += $(APP_ROOT)/$(PACKAGE_NAME)/examples/ssd1306_12832_sw_i2c_example.c# C_FILES += $(APP_ROOT)/$(PACKAGE_NAME)/examples/ssd1306_12864_hw_i2c_example.c# C_FILES += $(APP_ROOT)/$(PACKAGE_NAME)/examples/ssd1306_12864_sw_i2c_example.c 在同一个文件夹下打开src.mk，并追加几行, 123include rt-u8g2/rt-u8g2.mk# include rt_ili9341/rt_ili9341.mk# include ssd1306/ssd1306.mk 然后我选择模拟i2c，所以选择ssd1306_12832_sw_i2c_example.c， 12345678910111213141516171819202122232425262728293031323334353637383940#define OLED_I2C_PIN_SCL rt_pin_get(&quot;PC.0&quot;)#define OLED_I2C_PIN_SDA rt_pin_get(&quot;PC.1&quot;)int main(void)&#123; rt_pin_mode(LED0, PIN_MODE_OUTPUT); rt_kprintf(&quot;MCU-CH32V208WBU6\\r\\n&quot;); u8g2_t u8g2; // Initialization u8g2_Setup_ssd1306_i2c_128x32_univision_f(&amp;u8g2, U8G2_R0, u8x8_byte_sw_i2c, u8x8_rt_gpio_and_delay); u8x8_SetPin(u8g2_GetU8x8(&amp;u8g2), U8X8_PIN_I2C_CLOCK, OLED_I2C_PIN_SCL); u8x8_SetPin(u8g2_GetU8x8(&amp;u8g2), U8X8_PIN_I2C_DATA, OLED_I2C_PIN_SDA); u8g2_InitDisplay(&amp;u8g2); u8g2_SetPowerSave(&amp;u8g2, 0); int i = 10; char *ch1 = rt_malloc(20); char *ch2 = rt_malloc(30); ch1 = &quot;Hello, rx-ted,&quot;; while (i -= 1) &#123; u8g2_ClearBuffer(&amp;u8g2); u8g2_SetFont(&amp;u8g2, u8g2_font_ncenB08_tr); rt_sprintf(ch2, &quot;%s%d\\n&quot;, ch1, i); rt_kprintf(ch2); u8g2_DrawStr(&amp;u8g2, 1, 10, ch2); u8g2_SendBuffer(&amp;u8g2); rt_thread_mdelay(1000); // u8g2_ClearDisplay(&amp;u8g2); u8g2_DrawCircle(&amp;u8g2, 118, 20, 5, U8G2_DRAW_ALL); u8g2_SendBuffer(&amp;u8g2); rt_free(ch2); rt_thread_mdelay(1000); &#125; 代码传送门： github-&gt;03SSD1306","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"rt-thread移植","slug":"rt-thread移植","permalink":"https://rx-ted.github.io/blog/tags/rt-thread%E7%A7%BB%E6%A4%8D/"}]},{"title":"【沁恒 CH32V208 开发板免费试用】RTT 纯命令行(makefile) 和 点灯测试","slug":"【沁恒-CH32V208-开发板免费试用】纯命令行-makefile-和-点灯测试","date":"2023-05-24T10:24:01.000Z","updated":"2023-12-10T06:12:39.193Z","comments":true,"path":"/2023/05/24/【沁恒-CH32V208-开发板免费试用】纯命令行-makefile-和-点灯测试/","permalink":"https://rx-ted.github.io/blog/2023/05/24/%E3%80%90%E6%B2%81%E6%81%92-CH32V208-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%E3%80%91%E7%BA%AF%E5%91%BD%E4%BB%A4%E8%A1%8C-makefile-%E5%92%8C-%E7%82%B9%E7%81%AF%E6%B5%8B%E8%AF%95/","excerpt":"","text":"概述沁恒 CH32V208 开发板是一款基于risc-v内核的微控制器，具有丰富的外设资源和高性能的处理能力。本文介绍了如何使用makefile进行编译，并提供了一个简单的点灯测试程序示例，以验证开发板的基本功能是否正常。通过本文的介绍，读者可以快速上手使用沁恒 CH32V208 开发板进行开发。 环境&#x2F;工具需要借助一些软件和硬件相结合，做出项目. 软件 Windows10 (其他平台没测试) VScode make (针对makefile编译) risc-v 8.2.0 工具箱 (github有提供riscv-none-embed-XXX压缩包) WCHISPTOOLS (沁恒自带烧录工具) SERIAL DEBUG （查看调试日志） 首先，让我们来了解一下如何使用makefile进行编译。makefile是一种常用的自动化构建工具，它可以根据指定的规则自动化地生成目标文件和可执行文件。在使用makefile之前，需要安装GNU Make工具，并在项目目录下创建一个名为Makefile的文件。所以不借助平台来编译，只用纯命令行来执行，所以锻炼自己能力哈。 硬件 CH32V208开发板 wch-link (快递赠的) 测试接下来，让我们来看一下如何进行点灯测试。点灯测试是一种常用的测试方法，可以验证开发板的基本功能是否正常。在沁恒 CH32V208 开发板上，可以通过GPIO口控制LED灯的亮灭。 实例用makefile来编译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485TARGET := 01LEDinclude config.mkinclude src.mkCFLAGS += $(CPPPATHS)CXXFLAGS += $(CPPPATHS)AFLAGS += $(CPPPATHS)CFLAGS += $(DEFINES)CXXFLAGS += $(DEFINES)AFLAGS += $(DEFINES)TOOLCHAIN = riscv-none-embed-CC = $(TOOLCHAIN)gccSZ = $(TOOLCHAIN)sizeCP = $(TOOLCHAIN)objcopyAS = $(TOOLCHAIN)gccHEX = $(CP) -O ihexBIN = $(CP) -O binary -S# IOT positionROOT_DIR := ../../../..# bsp positionBSP_DIR := .BUILD_DIR = $(BSP_DIR)/buildLD_FILES = $(ROOT_DIR)/bsp/CH32V208/libraries/Ld/link.ldsFLAGS += -march=rv32imac -mabi=ilp32 -msmall-data-limit=8 -msave-restore -Os -fmessage-length=0 -fsigned-char -ffunction-sections -fdata-sections -fno-common -Wunused -Wuninitialized -g -std=gnu99 -DCH32V20x_D8W C_FLAGS += $(CC) $(CFLAGS) -MMD -MP -MF&quot;$(@:%.o=%.d)&quot; -MT&quot;$(@)&quot; -c -o &quot;$@&quot; &quot;$&lt;&quot;AS_FLAGS += $(CC) $(AFLAGS) -MMD -MP -MF&quot;$(@:%.o=%.d)&quot; -MT&quot;$(@)&quot; -c -o &quot;$@&quot; &quot;$&lt;&quot;LINK_FLAGS += $(CC) $(LFLAGS) $(EXTERN_LIB)# --specs=nano.specs all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).binOBJECT = $(addprefix $(BUILD_DIR)/,$(notdir $(S_FILES:.S=.o)))vpath %.S $(sort $(dir $(S_FILES)))OBJECT += $(addprefix $(BUILD_DIR)/,$(notdir $(C_FILES:.c=.o)))vpath %.c $(sort $(dir $(C_FILES)))OBJECTS += $(sort $(OBJECT))$(BUILD_DIR)/%.o:%.S Makefile | $(BUILD_DIR) $(AS_FLAGS)$(BUILD_DIR)/%.o:%.c Makefile | $(BUILD_DIR) $(C_FLAGS)$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) | Makefile $(LINK_FLAGS) $(OBJECTS) -o $@ $(SZ) --format=berkeley $@$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(HEX) $&lt; $@$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR) $(BIN) $&lt; $@$(BUILD_DIR): @echo $(OBJECTS) mkdir $@DATE = $(shell date)push: git add $(RTT_ROOT) git commit -m &quot;update :$(DATE)&quot; git push origin/mainc: rmdir /s /q build 其中include config.mk和include src.mk这2个在Bsp项目同一个文件夹下新建，内容是追加头文件，目标C后缀源代码，还有一些编译选项等等。 拿官方的例子，来验证测试是否正常，毕竟是用makefile，不确定这个项目编译是否有效果？ 123456789101112131415#define LED0 rt_pin_get(&quot;PA.0&quot;)int main(void)&#123; rt_pin_mode(LED0,PIN_MODE_OUTPUT); rt_kprintf(&quot;MCU-CH32V208WBU6\\r\\n&quot;); while(1) &#123; rt_pin_write(LED0, PIN_HIGH); rt_thread_mdelay(500); rt_pin_write(LED0, PIN_LOW); rt_thread_mdelay(500); &#125;&#125; 演示 代码传送门： github-&gt;01LED","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Bugs for hexo","slug":"Bugs-for-hexo","date":"2023-05-23T08:41:02.000Z","updated":"2023-12-10T06:12:39.377Z","comments":true,"path":"/2023/05/23/Bugs-for-hexo/","permalink":"https://rx-ted.github.io/blog/2023/05/23/Bugs-for-hexo/","excerpt":"","text":"Bugs for hexoon Hexo site, can meet some questions. PR extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pugnpm install hexo-renderer-pug hexo-renderer-stylus --save","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://rx-ted.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"milkv-duo 申请成功体验 DSC28034PNT-ch340g串口通信_FIFO","slug":"DSC28034PNT-ch340g串口通信","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:39.465Z","comments":true,"path":"/2023/05/20/DSC28034PNT-ch340g串口通信/","permalink":"https://rx-ted.github.io/blog/2023/05/20/DSC28034PNT-ch340g%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","excerpt":"实现DSC28034PNT与其他设备之间的数据交互。我们将使用CH340G作为USB转串口芯片，将DSC28034PNT与计算机或其他外部设备连接。通过串口通信，DSC28034PNT可以接收来自计算机或其他外部设备的命令和数据，并将其用于控制和操作","text":"DSC28034PNT-ch340g串口通信_FIFO项目概述DSC28034PNT是一款功能强大的数字信号控制器，而CH340G是一种常用的USB转串口芯片。在这个项目中，我们将探索如何使用DSC28034PNT和CH340G实现串口通信。串口通信是一种常见的数据传输方式，可用于在不同设备之间传输数据。 本项目旨在通过串口通信，实现DSC28034PNT与其他设备之间的数据交互。我们将使用CH340G作为USB转串口芯片，将DSC28034PNT与计算机或其他外部设备连接。通过串口通信，DSC28034PNT可以接收来自计算机或其他外部设备的命令和数据，并将其用于控制和操作。 软件调试在软件调试阶段，我们将关注串口通信的数据传输和处理。首先，我们需要在DSC28034PNT上设置串口通信的相关参数，如波特率、数据位、停止位等。接下来，我们将编写适当的代码来初始化串口通信，并实现数据的发送和接收功能。我们将使用适当的调试工具来检查数据传输的正确性，并解决可能遇到的问题。 硬件接入在硬件接入阶段，我们需要连接DSC28034PNT和CH340G，以便实现串口通信。首先，我们将连接CH340G的TX和RX引脚与DSC28034PNT的相应引脚，以实现数据的发送和接收。然后，我们将连接CH340G的USB接口与计算机或其他外部设备，以建立数据传输通道。 为确保稳定和可靠的硬件接入，我们需要注意正确连接引脚和检查电源供应，以避免电气问题和传输错误。 核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/*主程序入口*/int main(void)&#123; uint8 receiveData[4],i; //只接受4个字符，多余的补发 /*初始化系统控制*/ InitSysCtrl(); /*初始化内存控制寄存器，使能内存流水线模式*/ InitFlash(); /*初始化串口通信的GPIO口*/ /*GPIO28: SCIRXDA*/ /*GPIO29: SCITXDA*/ InitSciGpio(); /*SCI寄存器配置*/ Scia_Config(9600); /*通过SCI发送字符串*/ Scia_Print(&quot;----------- serial fifo test ------------\\r\\n&quot;); Scia_Print(&quot;Baud Rate: 9600\\r\\n&quot;); Scia_Print(&quot;Data Bits: 8\\r\\n&quot;); Scia_Print(&quot;Parity: none\\r\\n&quot;); Scia_Print(&quot;Stop Bits: 1\\r\\n&quot;); Scia_Print(&quot;\\r\\n&quot;); Scia_Print(&quot;I love H28034\\r\\n&quot;); for (;;) &#123; /*判断SCI是否接收到数据*/ if(SciaRegs.SCIFFRX.bit.RXFFST == 4) &#123; for(i = 0; i &lt; 4; i++) &#123; receiveData[i] = SciaRegs.SCIRXBUF.bit.RXDT; &#125; Scia_Print((char*)receiveData); Scia_Print(&quot;\\r\\n&quot;); &#125; &#125; return 0;&#125; 遇到问题 再一次烧录，需要全部拆掉保持关闭电源，然后重新上电 烧录完后没有自动运行主程序，需要手动按reset或者掉电才可以运行主程序 上述两个问题，怎么解决呢？特别是第一个问题，不要总是频繁掉电上电，损伤设备寿命。 总结通过上述项目概述、软件调试和硬件接入，我们将能够成功实现DSC28034PNT和CH340G之间的串口通信。这将为我们提供一个强大的数据交互平台，为各种应用提供了广泛的可能性，如控制系统、数据采集和传感器网络等。我们将不断改进和优化这个项目，以满足不断增长的需求和应用场景。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"DSC28034PNT-克隆ssd1306手动模拟i2c","slug":"DSC28034PNT-克隆ssd1306手动模拟i2c","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:39.549Z","comments":true,"path":"/2023/05/20/DSC28034PNT-克隆ssd1306手动模拟i2c/","permalink":"https://rx-ted.github.io/blog/2023/05/20/DSC28034PNT-%E5%85%8B%E9%9A%86ssd1306%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9Fi2c/","excerpt":"DSC28034PNT-克隆ssd1306手动模拟i2c","text":"DSC28034PNT-克隆ssd1306手动模拟i2cssd1306 sclk sda 对接 gpio18 gpio16 驱动器：SSD1306 分辨率：128*64 屏幕类型：OLED屏 物理接口：i2c 电压：3.3v 5v 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481/** * ssd1306 i2c oled display * 从tft模块引出i2c，如下 * sclk gpio18 * sda gpio16 */#include &quot;dsc_config.h&quot;#include &lt;syscalls.h&gt;#include &quot;IQmathLib.h&quot;#include&quot;oledfont.h&quot;u32 IntCount = 0;//OLED控制用函数#define OLED_MODE 0#define SIZE 8#define XLevelL 0x00#define XLevelH 0x10#define Max_Column 128#define Max_Row 64#define Brightness 0xFF#define X_WIDTH 128#define Y_WIDTH 64#define OLED_SCL_PIN GpioDataRegs.GPADAT.bit.GPIO18#define OLED_SDA_PIN GpioDataRegs.GPADAT.bit.GPIO16void OLED_SCLK_Clr() ;void OLED_SCLK_Set();void OLED_SDIN_Clr();void OLED_SDIN_Set();#define OLED_CMD 0 //写命令#define OLED_DATA 1 //写数据void OLED_WR_Byte(unsigned dat, unsigned cmd);void OLED_Display_On(void);void OLED_Display_Off(void);void OLED_Init(void);void OLED_Clear(void);void OLED_DrawPoint(u8 x, u8 y, u8 t);void OLED_Fill(u8 x1, u8 y1, u8 x2, u8 y2, u8 dot);void OLED_ShowChar(u8 x, u8 y, u8 chr, u8 Char_Size);void OLED_ShowNum(u8 x, u8 y, u32 num, u8 len, u8 size);void OLED_ShowString(u8 x, u8 y, u8 *p, u8 Char_Size);void OLED_Set_Pos(unsigned char x, unsigned char y);void OLED_ShowCHinese(u8 x, u8 y, u8 no);void OLED_DrawBMP(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char BMP[]);void Delay_50ms(unsigned int Del_50ms);void Delay_1ms(unsigned int Del_1ms);void fill_picture(unsigned char fill_Data);void Picture();void IIC_Start();void IIC_Stop();void Write_IIC_Command(unsigned char IIC_Command);void Write_IIC_Data(unsigned char IIC_Data);void Write_IIC_Byte(unsigned char IIC_Byte);void IIC_Wait_Ack();INTERRUPT void timer0_isr(void);void delay(uint32_t ms);void InitTimer();//OLED的显存//存放格式如下.//[0]0 1 2 3 ... 127//[1]0 1 2 3 ... 127//[2]0 1 2 3 ... 127//[3]0 1 2 3 ... 127//[4]0 1 2 3 ... 127//[5]0 1 2 3 ... 127//[6]0 1 2 3 ... 127//[7]0 1 2 3 ... 127/********************************************** //IIC Start **********************************************//********************************************** //IIC Start **********************************************/void IIC_Start() &#123; OLED_SCLK_Set(); OLED_SDIN_Set(); OLED_SDIN_Clr(); OLED_SCLK_Clr();&#125;/********************************************** //IIC Stop **********************************************/void IIC_Stop() &#123; OLED_SCLK_Set();// OLED_SCLK_Clr(); OLED_SDIN_Clr(); OLED_SDIN_Set();&#125;void IIC_Wait_Ack() &#123; //GPIOB-&gt;CRH &amp;= 0XFFF0FFFF; //设置PB12为上拉输入模式 //GPIOB-&gt;CRH |= 0x00080000;// OLED_SDA = 1;// delay_us(1); //OLED_SCL = 1; //delay_us(50000); /* while(1) &#123; if(!OLED_SDA) //判断是否接收到OLED 应答信号 &#123; //GPIOB-&gt;CRH &amp;= 0XFFF0FFFF; //设置PB12为通用推免输出模式 //GPIOB-&gt;CRH |= 0x00030000; return; &#125; &#125; */ OLED_SCLK_Set(); OLED_SCLK_Clr();&#125;/********************************************** // IIC Write byte **********************************************/void Write_IIC_Byte(unsigned char IIC_Byte) &#123; unsigned char i; unsigned char m, da; da = IIC_Byte; OLED_SCLK_Clr(); for (i = 0; i &lt; 8; i++) &#123; m = da; // OLED_SCLK_Clr(); m = m &amp; 0x80; if (m == 0x80) &#123; OLED_SDIN_Set(); &#125; else OLED_SDIN_Clr(); da = da &lt;&lt; 1; OLED_SCLK_Set(); OLED_SCLK_Clr(); &#125;&#125;/********************************************** // IIC Write Command **********************************************/void Write_IIC_Command(unsigned char IIC_Command) &#123; IIC_Start(); Write_IIC_Byte(0x78); //Slave address,SA0=0 IIC_Wait_Ack(); Write_IIC_Byte(0x00); //write command IIC_Wait_Ack(); Write_IIC_Byte(IIC_Command); IIC_Wait_Ack(); IIC_Stop();&#125;/********************************************** // IIC Write Data **********************************************/void Write_IIC_Data(unsigned char IIC_Data) &#123; IIC_Start(); Write_IIC_Byte(0x78); //D/C#=0; R/W#=0 IIC_Wait_Ack(); Write_IIC_Byte(0x40); //write data IIC_Wait_Ack(); Write_IIC_Byte(IIC_Data); IIC_Wait_Ack(); IIC_Stop();&#125;void OLED_WR_Byte(unsigned dat, unsigned cmd) &#123; if (cmd) &#123; Write_IIC_Data(dat); &#125; else &#123; Write_IIC_Command(dat); &#125;&#125;/******************************************** // fill_Picture ********************************************/void fill_picture(unsigned char fill_Data) &#123; unsigned char m, n; for (m = 0; m &lt; 8; m++) &#123; OLED_WR_Byte(0xb0 + m, 0); //page0-page1 OLED_WR_Byte(0x00, 0); //low column start address OLED_WR_Byte(0x10, 0); //high column start address for (n = 0; n &lt; 128; n++) &#123; OLED_WR_Byte(fill_Data, 1); &#125; &#125;&#125;/***********************Delay****************************************/void Delay_50ms(unsigned int Del_50ms) &#123; unsigned int m; for (; Del_50ms &gt; 0; Del_50ms--) for (m = 6245; m &gt; 0; m--) ;&#125;void Delay_1ms(unsigned int Del_1ms) &#123; unsigned char j; while (Del_1ms--) &#123; for (j = 0; j &lt; 123; j++) ; &#125;&#125;//坐标设置void OLED_Set_Pos(unsigned char x, unsigned char y) &#123; OLED_WR_Byte(0xb0 + y, OLED_CMD); OLED_WR_Byte(((x &amp; 0xf0) &gt;&gt; 4) | 0x10, OLED_CMD); OLED_WR_Byte((x &amp; 0x0f), OLED_CMD);&#125;//开启OLED显示void OLED_Display_On(void) &#123; OLED_WR_Byte(0X8D, OLED_CMD); //SET DCDC命令 OLED_WR_Byte(0X14, OLED_CMD); //DCDC ON OLED_WR_Byte(0XAF, OLED_CMD); //DISPLAY ON&#125;//关闭OLED显示void OLED_Display_Off(void) &#123; OLED_WR_Byte(0X8D, OLED_CMD); //SET DCDC命令 OLED_WR_Byte(0X10, OLED_CMD); //DCDC OFF OLED_WR_Byte(0XAE, OLED_CMD); //DISPLAY OFF&#125;//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!void OLED_Clear(void) &#123; u8 i, n; for (i = 0; i &lt; 8; i++) &#123; OLED_WR_Byte(0xb0 + i, OLED_CMD); //设置页地址（0~7） OLED_WR_Byte(0x00, OLED_CMD); //设置显示位置—列低地址 OLED_WR_Byte(0x10, OLED_CMD); //设置显示位置—列高地址 for (n = 0; n &lt; 128; n++) OLED_WR_Byte(0, OLED_DATA); &#125; //更新显示&#125;void OLED_On(void) &#123; u8 i, n; for (i = 0; i &lt; 8; i++) &#123; OLED_WR_Byte(0xb0 + i, OLED_CMD); //设置页地址（0~7） OLED_WR_Byte(0x00, OLED_CMD); //设置显示位置—列低地址 OLED_WR_Byte(0x10, OLED_CMD); //设置显示位置—列高地址 for (n = 0; n &lt; 128; n++) OLED_WR_Byte(1, OLED_DATA); &#125; //更新显示&#125;//在指定位置显示一个字符,包括部分字符//x:0~127//y:0~63//mode:0,反白显示;1,正常显示//size:选择字体 16/12void OLED_ShowChar(u8 x, u8 y, u8 chr, u8 Char_Size) &#123; unsigned char c = 0, i = 0; c = chr - &#x27; &#x27;; //得到偏移后的值 if (x &gt; Max_Column - 1) &#123; x = 0; y = y + 2; &#125; if (Char_Size == 16) &#123; OLED_Set_Pos(x, y); for (i = 0; i &lt; 8; i++) OLED_WR_Byte(F8X16[c * 16 + i], OLED_DATA); OLED_Set_Pos(x, y + 1); for (i = 0; i &lt; 8; i++) OLED_WR_Byte(F8X16[c * 16 + i + 8], OLED_DATA); &#125; else &#123; OLED_Set_Pos(x, y); for (i = 0; i &lt; 6; i++) OLED_WR_Byte(F6x8[c][i], OLED_DATA); &#125;&#125;//m^n函数u32 oled_pow(u8 m, u8 n) &#123; u32 result = 1; while (n--) result *= m; return result;&#125;//显示2个数字//x,y :起点坐标//len :数字的位数//size:字体大小//mode:模式 0,填充模式;1,叠加模式//num:数值(0~4294967295);void OLED_ShowNum(u8 x, u8 y, u32 num, u8 len, u8 size2) &#123; u8 t, temp; u8 enshow = 0; for (t = 0; t &lt; len; t++) &#123; temp = (num / oled_pow(10, len - t - 1)) % 10; if (enshow == 0 &amp;&amp; t &lt; (len - 1)) &#123; if (temp == 0) &#123; OLED_ShowChar(x + (size2 / 2) * t, y, &#x27; &#x27;, size2); continue; &#125; else enshow = 1; &#125; OLED_ShowChar(x + (size2 / 2) * t, y, temp + &#x27;0&#x27;, size2); &#125;&#125;//显示一个字符号串void OLED_ShowString(u8 x, u8 y, u8 *chr, u8 Char_Size) &#123; unsigned char j = 0; while (chr[j] != &#x27;\\0&#x27;) &#123; OLED_ShowChar(x, y, chr[j], Char_Size); x += 8; if (x &gt; 120) &#123; x = 0; y += 2; &#125; j++; &#125;&#125;//显示汉字void OLED_ShowCHinese(u8 x, u8 y, u8 no) &#123; u8 t;// u8 adder = 0; OLED_Set_Pos(x, y); for (t = 0; t &lt; 16; t++) &#123; OLED_WR_Byte(Hzk[2 * no][t], OLED_DATA);// adder += 1; &#125; OLED_Set_Pos(x, y + 1); for (t = 0; t &lt; 16; t++) &#123; OLED_WR_Byte(Hzk[2 * no + 1][t], OLED_DATA);// adder += 1; &#125;&#125;/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/void OLED_DrawBMP(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char BMP[]) &#123; unsigned int j = 0; unsigned char x, y; if (y1 % 8 == 0) y = y1 / 8; else y = y1 / 8 + 1; for (y = y0; y &lt; y1; y++) &#123; OLED_Set_Pos(x0, y); for (x = x0; x &lt; x1; x++) &#123; OLED_WR_Byte(BMP[j++], OLED_DATA); &#125; &#125;&#125;//初始化SSD1306void OLED_Init(void) &#123; EALLOW; GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 0; GpioCtrlRegs.GPADIR.bit.GPIO18 = 1; GpioCtrlRegs.GPAQSEL2.bit.GPIO18 = 0; GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 0; GpioCtrlRegs.GPADIR.bit.GPIO16 = 1; GpioCtrlRegs.GPAQSEL2.bit.GPIO16 = 0; EDIS; delay(800); OLED_WR_Byte(0xAE, OLED_CMD); //--display off OLED_WR_Byte(0x00, OLED_CMD); //---set low column address OLED_WR_Byte(0x10, OLED_CMD); //---set high column address OLED_WR_Byte(0x40, OLED_CMD); //--set start line address OLED_WR_Byte(0xB0, OLED_CMD); //--set page address OLED_WR_Byte(0x81, OLED_CMD); // contract control OLED_WR_Byte(0xFF, OLED_CMD); //--128 OLED_WR_Byte(0xA1, OLED_CMD); //set segment remap OLED_WR_Byte(0xA6, OLED_CMD); //--normal / reverse OLED_WR_Byte(0xA8, OLED_CMD); //--set multiplex ratio(1 to 64) OLED_WR_Byte(0x3F, OLED_CMD); //--1/32 duty OLED_WR_Byte(0xC8, OLED_CMD); //Com scan direction OLED_WR_Byte(0xD3, OLED_CMD); //-set display offset OLED_WR_Byte(0x00, OLED_CMD); // OLED_WR_Byte(0xD5, OLED_CMD); //set osc division OLED_WR_Byte(0x80, OLED_CMD); // OLED_WR_Byte(0xD8, OLED_CMD); //set area color mode off OLED_WR_Byte(0x05, OLED_CMD); // OLED_WR_Byte(0xD9, OLED_CMD); //Set Pre-Charge Period OLED_WR_Byte(0xF1, OLED_CMD); // OLED_WR_Byte(0xDA, OLED_CMD); //set com pin configuartion OLED_WR_Byte(0x12, OLED_CMD); // OLED_WR_Byte(0x30, OLED_CMD); // OLED_WR_Byte(0x8D, OLED_CMD); //set charge pump enable OLED_WR_Byte(0x14, OLED_CMD); // OLED_WR_Byte(0xAF, OLED_CMD); //--turn on oled panel&#125;void InitTimer() &#123; DINT; // 关闭CPU中断 InitPieCtrl(); //关闭清除CPU中断标记位 IER = 0X0000; IFR = 0X0000;// 初始化中断向量表 InitPieVectTable(); EALLOW;// 配置中断向量表 PieVectTable.TINT0 = &amp;timer0_isr; EDIS; EALLOW; //初始化模块 CpuTimer0Regs.TCR.bit.TSS = 1; CpuTimer0Regs.PRD.all = 120000; CpuTimer0Regs.TCR.bit.TIF = 1; CpuTimer0Regs.TCR.bit.TRB = 1; CpuTimer0Regs.TCR.bit.TIE = 1; CpuTimer0Regs.TCR.bit.TSS = 0; EDIS;//使能CPU中断 IER |= M_INT1;// 使能pie中断 PieCtrlRegs.PIEIER1.bit.INTx7 = 1; EINT; ERTM;&#125;//void CODE_SECTION(&quot;ramfuncs&quot;) //有无没区别void INTERRUPT timer0_isr() &#123; IntCount++; PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;&#125;void delay(u32 ms) &#123; u32 start = IntCount; while (IntCount - start &lt; ms) ;&#125;void OLED_SCLK_Clr() &#123; GpioDataRegs.GPACLEAR.bit.GPIO18 = 1;&#125;void OLED_SCLK_Set()&#123;GpioDataRegs.GPATOGGLE.bit.GPIO18 = 1;&#125;void OLED_SDIN_Clr() &#123; GpioDataRegs.GPACLEAR.bit.GPIO16 = 1;&#125;void OLED_SDIN_Set() &#123; GpioDataRegs.GPACLEAR.bit.GPIO16 = 1;&#125;int main(void)&#123; //InitFlash(); InitSysCtrl(); //Initializes the System Control registers to a known state. InitTimer(); OLED_Init(); delay(1000); OLED_On(); while(1)&#123; &#125; return 0;&#125;// ---------------------------------------------------------------------------- 可以复制，看看运行如何","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"milkv-duo 申请成功体验","slug":"milkv-duo-board","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:40.113Z","comments":true,"path":"/2023/05/20/milkv-duo-board/","permalink":"https://rx-ted.github.io/blog/2023/05/20/milkv-duo-board/","excerpt":"Milk-V Duo是一个基于CV1800B芯片的超紧凑嵌入式开发平台。它可以运行Linux和RTOS，为专业人士、工业ODM厂商、AIoT爱好者、DIY爱好者和创作者提供了一个可靠、低成本和高性能的平台。","text":"milkv-duo 申请成功体验前言Milk-V Duo是一种多功能的开发平台，使用CV1800B芯片作为核心处理单元。它支持运行Linux和RTOS，这意味着可以进行复杂的应用开发和实时任务处理。该平台可能广泛应用于专业领域、工业制造、物联网应用、个人创作等。由于其紧凑设计，Milk-V Duo可能适用于空间有限的场景。此外，它被宣传为低成本和高性能的选择，可能为开发者提供了一个相对经济且功能强大的开发环境。 开发板我高兴拿到一个大大的快递，可是拆开发现是只有大指母大小。。。我还以为丢了哈哈哈 别人提供的图片，看看对比，好小！！根据开发板上面颜色有五种以上，我已知有7种颜色。 引脚图 总结Milk-V Duo开发板的小巧精致设计和强悍的性能确实为创客和开发者提供了一个优秀的平台。它的紧凑设计使得它适用于各种空间有限的场景，同时强大的性能可以支持复杂的应用开发和实时任务处理。 对于创客和开发者来说，Milk-V Duo开发板可能是一个理想的选择。它提供了丰富的接口和功能，可以满足各种创意项目的需求。无论是从事物联网、人工智能、机器学习还是其他领域的开发，Milk-V Duo都能为我们提供良好的开发环境和体验。 此外，开源社区的支持和资源也为我们提供了更多的可能性。他们可以通过与其他开发者分享经验和交流想法，共同探索Milk-V Duo开发板的潜力，从而创造出更多有趣、实用的项目。 总的来说，Milk-V Duo开发板的小巧精致和强悍性能为我们提供了一个优秀的工具，激发了我们的创造力和创新精神。无论是个人项目还是商业应用，Milk-V Duo都有望成为一个可靠且强大的助力。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"基于milkv-duo环境编译","slug":"milkv-duo-env-compilation","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:40.205Z","comments":true,"path":"/2023/05/20/milkv-duo-env-compilation/","permalink":"https://rx-ted.github.io/blog/2023/05/20/milkv-duo-env-compilation/","excerpt":"Milk-V Duo是一个基于CV1800B芯片的超紧凑嵌入式开发平台。它可以运行Linux和RTOS，为专业人士、工业ODM厂商、AIoT爱好者、DIY爱好者和创作者提供了一个可靠、低成本和高性能的平台。","text":"milkv-duo envronment compilation基于milkv-duo环境编译 Milk-V Duo是一个基于CV1800B芯片的超紧凑嵌入式开发平台。它可以运行Linux和RTOS，为专业人士、工业ODM厂商、AIoT爱好者、DIY爱好者和创作者提供了一个可靠、低成本和高性能的平台。 安装虚拟机VBox + Ubuntu20.04 依赖1234sudo apt install pkg-config build-essential ninja-build automake autoconf libtool wget curl git gcc libssl-dev bc slib squashfs-tools android-sdk-libsparse-utils jq python3-distutils scons parallel tree python3-dev python3-pip device-tree-compiler ssh cpio fakeroot libncurses5 flex bison libncurses5-dev genext2fs rsync unzip dosfstools mtools tclsh ssh-client android-sdk-ext4-utilswget https://github.com/Kitware/CMake/releases/download/v3.26.4/cmake-3.26.4-linux-x86_64.shchmod +x cmake-3.26.4-linux-x86_64.shsudo sh cmake-3.26.4-linux-x86_64.sh --skip-license --prefix=/usr/local/ 添加一些package1234source ./build/cvisetup.shdefconfig cv1800b_milkv_duo_sd menuconfig# 可以添加或者删除一些软件和配置 编译打包可以查看env.sh源代码 说明每个平台是不一样，希望大家稍微修改哈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/bin/bashMILKV_BOARD_DIR=milkvMILKV_BOARD_ARRAY=MILKV_BOARD=MILKV_BOARD_CONFIG=current_dir=$PWD;toolchain_name[0]=&quot;riscv64-elf-x86_64&quot;toolchain_name[1]=&quot;riscv64-linux-x86_64&quot;toolchain_name[2]=&quot;riscv64-linux-musl-x86_64&quot;get_toolchain() &#123; f1=$(find . -name $&#123;toolchain_name[0]&#125; ) f2=$(find . -name $&#123;toolchain_name[1]&#125; ) f3=$(find . -name $&#123;toolchain_name[2]&#125; ) if [[ $f1 &amp;&amp; $f2 &amp;&amp; $f3 ]]; then echo &quot;$&#123;toolchain_name[0]&#125; $&#123;toolchain_name[1]&#125; $&#123;toolchain_name[2]&#125; is found.&quot; else echo &quot;Toolchain does not exist, download it now...&quot; toolchain_url=&quot;https://sophon-file.sophon.cn/sophon-prod-s3/drive/23/03/07/16/host-tools.tar.gz&quot; echo &quot;toolchain_url: $&#123;toolchain_url&#125;&quot; toolchain_file=$&#123;toolchain_url##*/&#125; echo &quot;toolchain_file: $&#123;toolchain_file&#125;&quot; wget $&#123;toolchain_url&#125; -O $&#123;toolchain_file&#125; if [ $? -ne 0 ]; then echo &quot;Failed to download $&#123;toolchain_url&#125; !&quot; exit 1 fi if [ ! -f $&#123;toolchain_file&#125; ]; then echo &quot;$&#123;toolchain_file&#125; not found!&quot; exit 1 fi echo &quot;Extracting $&#123;toolchain_file&#125;...&quot; tar -xf $&#123;toolchain_file&#125; if [ $? -ne 0 ]; then echo &quot;Extract $&#123;toolchain_file&#125; failed!&quot; exit 1 fi [ -f $&#123;toolchain_file&#125; ] &amp;&amp; rm -rf $&#123;toolchain_file&#125; IFS=&#x27;.&#x27; read -ra parts &lt;&lt;&lt; &quot;$toolchain_file&quot; echo &quot;$current_dir/$&#123;parts[0]&#125;/gcc/$&#123;toolchain_name[0]&#125;/bin&quot; &gt;&gt; env.txt echo &quot;$current_dir/$&#123;parts[0]&#125;/gcc/$&#123;toolchain_name[1]&#125;/bin&quot; &gt;&gt; env.txt echo &quot;$current_dir/$&#123;parts[0]&#125;/gcc/$&#123;toolchain_name[2]&#125;/bin&quot; &gt;&gt; env.txt if [ &quot;$(source env.txt)&quot; ]; then echo &quot;source env.txt&quot;; fi fi&#125;function get_available_board()&#123; cd $&#123;MILKV_BOARD_DIR&#125; || exit 1 MILKV_BOARD_ARRAY=( $(ls boardconfig*.sh | sort | awk -F&quot;[-.]&quot; -v OFS=&#x27;-&#x27; &#x27;&#123;print $2, $3&#125;&#x27;) ) echo &quot;$&#123;MILKV_BOARD_ARRAY[@]&#125;&quot; if [ $&#123;#MILKV_BOARD_ARRAY[@]&#125; -eq 0 ]; then echo &quot;No available board config&quot; exit 1 elif [ $&#123;#MILKV_BOARD_ARRAY[@]&#125; -eq 1 ]; then # Only one board echo &quot;Ready to build: $&#123;MILKV_BOARD_ARRAY[0]&#125;&quot; MILKV_BOARD=$&#123;MILKV_BOARD_ARRAY[0]&#125; else echo &quot;other board&quot; fi if [ -z &quot;$&#123;MILKV_BOARD// &#125;&quot; ]; then echo &quot;No board specified!&quot; exit 1fi&#125;get_toolchainget_available_board export MILKV_BOARD=&quot;$&#123;MILKV_BOARD&#125;&quot;cd &quot;$&#123;current_dir&#125;&quot; || exit 1MILKV_BOARD_CONFIG=$&#123;MILKV_BOARD_DIR&#125;/boardconfig-$&#123;MILKV_BOARD&#125;.shif [ ! -f $&#123;MILKV_BOARD_CONFIG&#125; ]; then echo &quot;$&#123;MILKV_BOARD_CONFIG&#125; not found!&quot; exit 1fisource $&#123;MILKV_BOARD_CONFIG&#125;source build/$&#123;MV_BUILD_ENV&#125; &gt; /dev/null 2&gt;&amp;1defconfig $&#123;MV_BOARD_LINK&#125; &gt; /dev/null 2&gt;&amp;1echo &quot;OUTPUT_DIR: $&#123;OUTPUT_DIR&#125;&quot; # @build/milkvsetup.shif [ $# -eq 1 ];then clean_allfibuild_allpack_sd_image 执行如下命令： 12345# 第一次编译时候可以用./env.sh# 不是第一次编译时候可以用，先清理缓存# ./env.sh arg1 arg1表示参数1，内容没固定，随便写./env.sh 1 或者想在镜像添加一些文件，如python，gdb等，需要如下命令： 123456source ./build/cvisetup.shdefconfig cv1800b_milkv_duo_sdmenuconfig# 可以选择你喜欢的东西，然后可以运行build_allpack_sd_image image上述步骤，正常运行编译打包，导出image镜像，如下：install&#x2F;soc_cv1800b_milkv_duo_sd&#x2F;milkv-duo.img 烧录方式可以是SD卡或者其他工具 判断是否成功测试ping 192.168.42.1需要安装依赖驱动哈 建议 不要安装在Windows系统下编译 即是在Windows用wsl环境下配置，不建议 在Linux或者容器或者虚拟机，不要直连Windows下路径，有时候莫名其妙出一些问题 搬抄按照步骤去做，发现有一些依赖文件没安装，需要分析一下","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"milkv-duo 基于shell点亮LED","slug":"milkv-duo-gpio-led","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:40.289Z","comments":true,"path":"/2023/05/20/milkv-duo-gpio-led/","permalink":"https://rx-ted.github.io/blog/2023/05/20/milkv-duo-gpio-led/","excerpt":"XXX","text":"milkv-duo 基于shell点亮LED第一次见在shell操作gpio开关LED","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"milkv-duo-windows不支持RNDIS-ssh登录解决方案","slug":"milkv-duo-windows不支持RNDIS-ssh登录解决方案","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:40.441Z","comments":true,"path":"/2023/05/20/milkv-duo-windows不支持RNDIS-ssh登录解决方案/","permalink":"https://rx-ted.github.io/blog/2023/05/20/milkv-duo-windows%E4%B8%8D%E6%94%AF%E6%8C%81RNDIS-ssh%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"Milk-V Duo开发板在Windows系统下不支持RNDIS-SSH登录，用户无法通过此方式进行远程登录和管理。这对于那些习惯使用SSH进行远程操作的用户来说，可能会影响开发效率和使用体验。","text":"milkv-duo-windows不支持RNDIS-ssh登录解决方案Milk-V Duo是一款基于CV1800B芯片的超紧凑嵌入式开发平台，性能强悍，为专业人士、工业ODM厂商、AIoT爱好者、DIY爱好者和创作者提供了一个可靠、低成本和高性能的平台。然而，部分用户反馈在使用Milk-V Duo开发板时，发现其Windows系统下不支持RNDIS-SSH登录，给用户的使用带来了一定的不便。本报告将探讨该问题的原因，并提供可能的解决方案。 ssh登陆第一次ssh登陆，发现没反应，原因如下图：第二次ssh登陆，成功进去，原因就是没有导入rdins驱动 问题描述Milk-V Duo开发板在Windows系统下不支持RNDIS-SSH登录，用户无法通过此方式进行远程登录和管理。这对于那些习惯使用SSH进行远程操作的用户来说，可能会影响开发效率和使用体验。 可能原因问题可能是由于Windows系统对RNDIS协议的支持不完善导致的。RNDIS是一种用于在设备之间进行网络连接的协议，而SSH则是一种安全的远程登录协议。由于Windows系统的特殊性，可能存在与RNDIS协议的兼容性问题，导致SSH登录功能无法正常使用。 解决方案针对该问题，尝试以下解决方案：使用其他操作系统：考虑使用其他支持RNDIS协议和SSH登录的操作系统，比如Linux或MacOS。这些操作系统通常对RNDIS协议的支持更完善，能够更好地满足用户的需求。 咨询官方技术支持：如果该问题无法解决，建议看Milk-V Duo的官方技术支持团队。他们可能能够提供更具体的解决方案或者更新的固件版本，以解决该问题。可以访问—-&gt;rndis-setup 更新RNDIS驱动：Windows上本来没有安装该驱动，需要更新一下就行了。 结论虽然Milk-V Duo开发板在Windows系统下不支持RNDIS-SSH登录，但用户可以通过ttl或者以太网来解决问题。Milk-V Duo作为一款强悍且多功能的开发平台，相信未来将会不断更新和改进，为用户带来更好的使用体验。","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"实时显示 更进一步 又快又准","slug":"real-time-lcd","date":"2023-05-20T05:15:05.000Z","updated":"2023-12-10T06:12:40.661Z","comments":true,"path":"/2023/05/20/real-time-lcd/","permalink":"https://rx-ted.github.io/blog/2023/05/20/real-time-lcd/","excerpt":"FireBeetle 2 ESP32-S3可以使用Arduino IDE、ESP-IDF、MicroPython进行编程，C语言、python都可以轻松的操纵硬件。我选择以vscode为主，插件platformio，需要安装python3. Purple Pi开发板通过J12排针提供了丰富的GPIO接口，包括UART、SPI、I2C、GPIO等（还包括DC5V、DC3.3V、GND）。","text":"实时显示 更进一步 又快又准简介FireBeetle 2 ESP32-S3可以使用Arduino IDE、ESP-IDF、MicroPython进行编程，C语言、python都可以轻松的操纵硬件。我选择以vscode为主，插件platformio，需要安装python3.Purple Pi开发板通过J12排针提供了丰富的GPIO接口，包括UART、SPI、I2C、GPIO等（还包括DC5V、DC3.3V、GND）。 引脚概述 GPIO：常规引脚 Analog：模拟输入引脚 ADC：模数转换 TOUCH：触摸引脚 SPI：SPI接口 I2C：I2C接口 UART：UART接口 USB：USB接口 JTAG：调试接口 3V3：3.3V稳压电源输出 VCC：电源输入&#x2F;输出 输入：5V DC输入为FireBeetle供电（无法为锂电池充电） 输出：5V-USB 供电时输出USB电压，3.7V-锂电池供电时输出锂电池电压 GND：公共地引脚 引脚示意图 引脚关系图 board extend IO1&#x2F;SDA SSD1306-SDA IO2&#x2F;SCL SSD1306-SCK IO7&#x2F;D5 DS1302-SCK IO38&#x2F;D3 DS1302-DO IO3&#x2F;D2 DS1302-RST 如下图： 为什么要设计？在SSD1306上获取实时是指在SSD1306液晶显示屏上显示实时的时间或其它信息。为了实现这一功能，需要通过一个实时时钟（RTC）模块来获取实时的时间，并将时间信息传递给SSD1306液晶显示屏进行显示。 DS1302是一种常用的实时时钟芯片，它具有掉电不丢失时间的特性，即使在掉电的情况下，它仍能保存当前的时间信息。因此，将DS1302与SSD1306结合使用，可以实现在掉电或烧录后仍然能够获取实时时间，并在液晶显示屏上显示。 这样的设计可以使设备具有更好的用户体验，即使在掉电或重新烧录程序的情况下，用户也能看到实时的时间信息，而不需要重新设置时间。这对于一些需要精确时间信息的应用场景是非常有用的，比如钟表、计时器等。 基于01SHOWTIME开源改进一些内容源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// CONNECTIONS:// DS1302 CLK/SCLK --&gt; 7// DS1302 DAT/IO --&gt; 38// DS1302 RST/CE --&gt; 3// DS1302 VCC --&gt; 3.3v - 5v// DS1302 GND --&gt; GND// SSD1306 SCK --&gt; IO2/SCL// SSD1306 SDA --&gt; IO1/SDA// SSD1306 GND --&gt; GND// SSD1306 VDD --&gt; 3.3V#include &quot;OLEDDisplayUi.h&quot;#include &quot;SSD1306Wire.h&quot;#include &quot;images.h&quot;#include &lt;RtcDS1302.h&gt;#include &lt;TimeLib.h&gt;#include &lt;Wire.h&gt;void printDateTime(const RtcDateTime &amp;dt);#define countof(a) (sizeof(a) / sizeof(a[0]))ThreeWire myWire(38, 7, 3); // IO, SCLK, CESSD1306Wire display(0x3c, SDA, SCL); // IO1 IO2RtcDS1302&lt;ThreeWire&gt; Rtc(myWire);OLEDDisplayUi ui(&amp;display);int screenW = 128;int screenH = 64;int clockCenterX = screenW / 2;int clockCenterY = ((screenH - 16) / 2) + 16; // top yellow part is 16 px heightint clockRadius = 23;// utility function for digital clock display: prints leading 0String twoDigits(int digits)&#123; if (digits &lt; 10) &#123; String i = &#x27;0&#x27; + String(digits); return i; &#125; else &#123; return String(digits); &#125;&#125;void clockOverlay(OLEDDisplay *display, OLEDDisplayUiState *state)&#123;&#125;void analogClockFrame(OLEDDisplay *display, OLEDDisplayUiState *state, int16_t x, int16_t y)&#123; // ui.disableIndicator(); // Draw the clock face // display-&gt;drawCircle(clockCenterX + x, clockCenterY + y, clockRadius); display-&gt;drawCircle(clockCenterX + x, clockCenterY + y, 2); // // hour ticks for (int z = 0; z &lt; 360; z = z + 30) &#123; // Begin at 0° and stop at 360° float angle = z; angle = (angle / 57.29577951); // Convert degrees to radians int x2 = (clockCenterX + (sin(angle) * clockRadius)); int y2 = (clockCenterY - (cos(angle) * clockRadius)); int x3 = (clockCenterX + (sin(angle) * (clockRadius - (clockRadius / 8)))); int y3 = (clockCenterY - (cos(angle) * (clockRadius - (clockRadius / 8)))); display-&gt;drawLine(x2 + x, y2 + y, x3 + x, y3 + y); &#125; // display second hand float angle = second() * 6; angle = (angle / 57.29577951); // Convert degrees to radians int x3 = (clockCenterX + (sin(angle) * (clockRadius - (clockRadius / 5)))); int y3 = (clockCenterY - (cos(angle) * (clockRadius - (clockRadius / 5)))); display-&gt;drawLine(clockCenterX + x, clockCenterY + y, x3 + x, y3 + y); // // display minute hand angle = minute() * 6; angle = (angle / 57.29577951); // Convert degrees to radians x3 = (clockCenterX + (sin(angle) * (clockRadius - (clockRadius / 4)))); y3 = (clockCenterY - (cos(angle) * (clockRadius - (clockRadius / 4)))); display-&gt;drawLine(clockCenterX + x, clockCenterY + y, x3 + x, y3 + y); // // display hour hand angle = hour() * 30 + int((minute() / 12) * 6); angle = (angle / 57.29577951); // Convert degrees to radians x3 = (clockCenterX + (sin(angle) * (clockRadius - (clockRadius / 2)))); y3 = (clockCenterY - (cos(angle) * (clockRadius - (clockRadius / 2)))); display-&gt;drawLine(clockCenterX + x, clockCenterY + y, x3 + x, y3 + y);&#125;void digitalClockFrame(OLEDDisplay *display, OLEDDisplayUiState *state, int16_t x, int16_t y)&#123; String timenow = String(hour()) + &quot;:&quot; + twoDigits(minute()) + &quot;:&quot; + twoDigits(second()); display-&gt;setTextAlignment(TEXT_ALIGN_CENTER); display-&gt;setFont(ArialMT_Plain_24); display-&gt;drawString(clockCenterX + x, clockCenterY + y, timenow);&#125;void printDateTime(const RtcDateTime &amp;dt)&#123; char datestring[26]; snprintf_P(datestring, countof(datestring), PSTR(&quot;%02u/%02u/%04u %02u:%02u:%02u&quot;), dt.Month(), dt.Day(), dt.Year(), dt.Hour(), dt.Minute(), dt.Second()); Serial.print(datestring);&#125;void clock_init()&#123; Rtc.Begin(); RtcDateTime compiled = RtcDateTime(__DATE__, __TIME__); printDateTime(compiled); Serial.println(); if (!Rtc.IsDateTimeValid()) &#123; // Common Causes: // 1) first time you ran and the device wasn&#x27;t running yet // 2) the battery on the device is low or even missing Serial.println(&quot;RTC lost confidence in the DateTime!&quot;); Rtc.SetDateTime(compiled); &#125; if (Rtc.GetIsWriteProtected()) &#123; Serial.println(&quot;RTC was write protected, enabling writing now&quot;); Rtc.SetIsWriteProtected(false); &#125; if (!Rtc.GetIsRunning()) &#123; Serial.println(&quot;RTC was not actively running, starting now&quot;); Rtc.SetIsRunning(true); &#125; RtcDateTime now = Rtc.GetDateTime(); if (now &lt; compiled) &#123; Serial.println(&quot;RTC is older than compile time! (Updating DateTime)&quot;); Rtc.SetDateTime(compiled); &#125; else if (now &gt; compiled) &#123; Serial.println(&quot;RTC is newer than compile time. (this is expected)&quot;); &#125; else if (now == compiled) &#123; Serial.println(&quot;RTC is the same as compile time! (not expected but all is fine)&quot;); &#125;&#125;// This array keeps function pointers to all frames// frames are the single views that slide inFrameCallback frames[] = &#123;analogClockFrame, digitalClockFrame&#125;;// how many frames are there?int frameCount = 2;// Overlays are statically drawn on top of a frame eg. a clockOverlayCallback overlays[] = &#123;clockOverlay&#125;;int overlaysCount = 1;void setup()&#123; Serial.begin(115200); RtcDateTime now = Rtc.GetDateTime(); Serial.print(&quot;compiled: &quot;); Serial.print(__DATE__); Serial.println(__TIME__); // clock function clock_init(); // init time and date Serial.println(&quot;Init time and date~&quot;); ui.setTargetFPS(60); // Customize the active and inactive symbol ui.setActiveSymbol(activeSymbol); ui.setInactiveSymbol(inactiveSymbol); // You can change this to // TOP, LEFT, BOTTOM, RIGHT ui.setIndicatorPosition(TOP); // Defines where the first frame is located in the bar. ui.setIndicatorDirection(LEFT_RIGHT); // You can change the transition that is used // SLIDE_LEFT, SLIDE_RIGHT, SLIDE_UP, SLIDE_DOWN ui.setFrameAnimation(SLIDE_LEFT); // Add frames ui.setFrames(frames, frameCount); // Add overlays ui.setOverlays(overlays, overlaysCount); // Initialising the UI will init the display too. ui.init(); display.flipScreenVertically(); // 从ds1302获取实时 setTime(now.Hour(), now.Minute(), now.Second(), now.Day(), now.Month(), now.Year());&#125;void loop()&#123; int remainingTimeBudget = ui.update(); if (remainingTimeBudget &gt; 0) &#123; delay(remainingTimeBudget); &#125;&#125; 演示","categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"hexo一定要了解的步骤","slug":"hexo一定要了解的步骤","date":"2023-05-17T05:15:05.000Z","updated":"2023-12-10T06:12:40.017Z","comments":true,"path":"/2023/05/17/hexo一定要了解的步骤/","permalink":"https://rx-ted.github.io/blog/2023/05/17/hexo%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%AD%A5%E9%AA%A4/","excerpt":"使用hexo概括一些command","text":"commandinit新建一个网站 1hexo init [folder] new新建文章 1hexo new [option] &lt;title&gt; 创建一篇文章名为“hexo create” 1hexo new &quot;hexo create&quot; option description -p,–path 指定路径 -r,–repalce 替换文章 -s,–slug 发布文件名和url generate12hexo generatehexo g option description -d,–deploy 生成直接部署 -w,–watch 监视变动 -b,–bail 异常抛出 -f,–force 强制重新生成文件 -c,–concurrency 数量不限制 publish发表草稿 1hexo publish [option] [filename] server启动网页服务 12hexo serverhexo s option description -p,–port 端口 -s,–static 静态设置 -l,–log 日志记录 deploy部署网站 12hexo deployhexo d render渲染文件 1hexo render &lt;file1&gt; [filex] option description -o,–output 设置输出路径 clean清除缓存 12hexo cleanhexo c list列出网站资料 1hexo list &lt;type&gt; version查看版本 12hexo versionhexo v 选项1234hexo --safe # 安全模式hexo --debug # 调试模式hexo --silent # 简洁模式hexo --draft # 显示草稿","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://rx-ted.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"My English Resume","slug":"My-English-Resume","date":"2023-05-16T02:00:00.000Z","updated":"2023-12-10T06:12:40.569Z","comments":true,"path":"/2023/05/16/My-English-Resume/","permalink":"https://rx-ted.github.io/blog/2023/05/16/My-English-Resume/","excerpt":"my english resume ,use table webpages to put resume.","text":"My Resume Online resume General Information Name Ben Gao Gender Male Birthdate 11/5/1998 Birthplace Anhui E-mail gjy.18sui@gmail.com Cell phone 17372264057 Job Intention Software Engineer Skills Python, C/C++, CET-4, Arduino/RTOS, HTML/CSS/JS/jQuery, MySQL and so on. Education Background 2018.9-2022.7, undergraduate, major in Computer Science and Technology, Beijing Union University. Professional Experience In June 2021, I took an embedded position in Beijing Electromagnetic Fangyuan Company. I first sorted out the data and turned it into a word file. Secondly, I designed a set of simple web socket based on TCP/IP. Finally, I copied a DC program from Python to C language. Since June 2022, I was in the position of material coordinator in Flex Suzhou Co. LTD. My work content is material coordination, account adjustment, scrap, report, inventory analysis. For example, I have the ability of coordination and communication and the basic command and use of office software. I pay tax according to the state tax laws and regulations. I process and maintain material management data. I regularly analyze financial statements to provide detailed and solid basis for the company's operation and management decisions. I check the monthly inventory. Self-Evaluation I am warm-hearted, friendly, honest and modest. I have strong self-study and practical ability, and can quickly accept new things. I am good at communicating with my colleagues and leaders so that I can quickly solve the problems encountered in the project. I have a hard-working spirit and good development habits. I want to find a job that is challenging and I like to be constantly challenged. I believe that the position in your company meets my need. I also like the equal and friendly environment in your company. I believe I can gain a lot from working in this kind of company environment.","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://rx-ted.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"简历","slug":"简历","permalink":"https://rx-ted.github.io/blog/tags/%E7%AE%80%E5%8E%86/"}]},{"title":"github 美化","slug":"个人主页","date":"2023-03-11T07:38:59.000Z","updated":"2023-12-10T06:12:40.745Z","comments":true,"path":"/2023/03/11/个人主页/","permalink":"https://rx-ted.github.io/blog/2023/03/11/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/","excerpt":"","text":"Hi there 👋 Hi 👋, I'm Gao Jingyi &emsp; &emsp; &emsp; &emsp; &nbsp; Connect with me: 👨‍💻 All of my projects are available at https://github.com/rx-ted 📝 I regularly write articles on https://rx-ted.github.io/blog 📫 How to reach me &#103;&#106;&#x79;&#46;&#x31;&#56;&#x73;&#117;&#105;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109; 📄 Know about my experiences 等上传 Languages and Tools: Python&nbsp;(Core) C C++ Arduino Hexo Git Linux Powershell MySQL ... ...... ...","categories":[],"tags":[]},{"title":"【国民技术N32项目移植】基于Arduino简单版的点灯项目移植","slug":"【国民技术N32项目移植】基于Arduino简单版的点灯项目移植","date":"2023-03-04T14:53:38.000Z","updated":"2023-12-10T06:12:38.641Z","comments":true,"path":"/2023/03/04/【国民技术N32项目移植】基于Arduino简单版的点灯项目移植/","permalink":"https://rx-ted.github.io/blog/2023/03/04/%E3%80%90%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D%E3%80%91%E5%9F%BA%E4%BA%8EArduino%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84%E7%82%B9%E7%81%AF%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/","excerpt":"","text":"【国民技术N32项目移植】基于Arduino简单版的点灯项目移植N32G4FR 简单移植arduino库，简单点灯熄灯，延迟开灯等反复的点亮LED一秒钟，然后关闭LED一秒钟。 功能1234567891011121314151617181920212223242526272829303132// 创建Arduino.h// 模仿函数/** * pinMode() * @param pin—引脚 GPIO序号 查看pin.c源代码 * @param Mode—模式 1.输出(OUTPUT)模式;2.输入(INPUT)模式;3.输入上拉（INPUT_PULLUP）模式 */pinMode(pin,Mode) // 函数：定义引脚模式/** * digitalWrite() * @param pin：GPIO序号 查看pin.c源代码 * @param value：HIGH或LOW */digitalWrite(pin, value)/** * delay() * @param ms 多少毫秒 */delay(ms)//for exampleint main()&#123; int ledPin = PIN_GET(B,5);//定义引脚D3 pinMode( ledPin, OUTPUT); while(1)&#123; digitalWrite(ledPin, HIGH);//LED灯亮 delay(1000);//等待1秒 digitalWrite(ledPin, LOW);//LED灯灭 delay(1000); &#125;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &quot;drv_gpio.h&quot;#include &quot;drv_usart.h&quot;#include &quot;pin.h&quot;#include &quot;serial.h&quot;#include &lt;rtthread.h&gt;#ifdef RT_USING_DFS/* dfs filesystem:ELM filesystem init */#include &lt;dfs_elm.h&gt;/* dfs Filesystem APIs */#include &lt;dfs_fs.h&gt;#endif#ifdef RT_USING_RTGUI#include &lt;rtgui/calibration.h&gt;#include &lt;rtgui/driver.h&gt;#include &lt;rtgui/rtgui.h&gt;#include &lt;rtgui/rtgui_server.h&gt;#include &lt;rtgui/rtgui_system.h&gt;#endif/* Official Arduino */#define LOW 0x0#define HIGH 0x1#define CHANGE 0x2#define FALLING 0x3#define RISING 0x4#define INPUT 0x0#define OUTPUT 0x1#define INPUT_PULLUP 0x2/* RT-Thread extension */#define INPUT_FLOATING INPUT#define INPUT_PULLDOWN 0x3#define OUTPUT_OPEN_DRAIN 0x4ALIGN(RT_ALIGN_SIZE)static rt_uint8_t led0_stack[512], led1_stack[512];static struct rt_thread led0_thread;static struct rt_thread led1_thread;#define LED1_PIN GET_PIN(A, 8)#define LED3_PIN GET_PIN(B, 5)/** * @brief led0 thread entry */static void led0_thread_entry(void *parameter)&#123; while (1) &#123; rt_thread_delay(50); // delay 500ms rt_pin_write(LED1_PIN, PIN_HIGH); rt_thread_delay(50); // delay 500ms rt_pin_write(LED1_PIN, PIN_LOW); &#125;&#125;/** * @brief led1 thread entry */static void led1_thread_entry(void *parameter)&#123; while (1) &#123; rt_thread_delay(25); // delay 250ms rt_pin_write(LED3_PIN, PIN_HIGH); rt_thread_delay(25); // delay 250ms rt_pin_write(LED3_PIN, PIN_LOW); &#125;&#125;#ifdef RT_USING_RTGUIrt_bool_t cali_setup(void)&#123; rt_kprintf(&quot;cali setup entered\\n&quot;); return RT_FALSE;&#125;void cali_store(struct calibration_data *data)&#123; rt_kprintf(&quot;cali finished (%d, %d), (%d, %d)\\n&quot;, data-&gt;min_x, data-&gt;max_x, data-&gt;min_y, data-&gt;max_y);&#125;#endif /* RT_USING_RTGUI */int led1()&#123; rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT); rt_err_t result; /* init led0 thread */ result = rt_thread_init(&amp;led0_thread, &quot;led0&quot;, led0_thread_entry, RT_NULL, (rt_uint8_t *)&amp;led0_stack[0], sizeof(led0_stack), 4, 5); if (result != RT_EOK) &#123; rt_kprintf(&quot;create task for red led is failed!\\n&quot;); return -1; &#125; rt_thread_startup(&amp;led0_thread); return 0;&#125;int led2()&#123; rt_pin_mode(LED3_PIN, PIN_MODE_OUTPUT); rt_err_t result; /* init led1 thread */ result = rt_thread_init(&amp;led1_thread, &quot;led1&quot;, led1_thread_entry, RT_NULL, (rt_uint8_t *)&amp;led1_stack[0], sizeof(led1_stack), 5, 5); if (result != RT_EOK) &#123; rt_kprintf(&quot;create task for green led is failed!\\n&quot;); return -1; &#125; rt_thread_startup(&amp;led1_thread); return 0;&#125;void pinMode(uint8_t pin, uint8_t mode)&#123; rt_base_t rt_mode; switch(mode) &#123; case INPUT: rt_mode = PIN_MODE_INPUT; break; case OUTPUT: rt_mode = PIN_MODE_OUTPUT; break; case INPUT_PULLUP: rt_mode = PIN_MODE_INPUT_PULLUP; break; case INPUT_PULLDOWN: rt_mode = PIN_MODE_INPUT_PULLDOWN; break; case OUTPUT_OPEN_DRAIN: rt_mode = PIN_MODE_OUTPUT_OD; break; default: rt_mode = RT_NULL; // LOG_E(&quot;pinMode mode parameter is illegal&quot;); return; &#125; rt_pin_mode(pin, rt_mode);&#125;void digitalWrite(uint8_t pin, uint8_t val)&#123; rt_base_t rt_val; if(val == HIGH) &#123; rt_val = PIN_HIGH; &#125; else if(val == LOW) &#123; rt_val = PIN_LOW; &#125; else &#123; return; &#125; rt_pin_write(pin, rt_val);&#125;void delay(unsigned long ms)&#123; rt_thread_mdelay(ms);&#125;/** * @brief Main program */int main(void)&#123; pinMode( LED1_PIN, OUTPUT); while(1)&#123; digitalWrite(LED1_PIN, HIGH);//LED灯亮 delay(1000);//等待1秒 digitalWrite(LED1_PIN, LOW);//LED灯灭 delay(1000); &#125; return 0;&#125;MSH_CMD_EXPORT(led1, &quot;red led blink&quot;)MSH_CMD_EXPORT(led2, &quot;blue led blink&quot;)/*@&#125;*/// 总结实现了，脑子会想到与N32G4FR和Arduino完全相同的，是的arduino上的语法N32G4FR都兼容的。这让我们面对N32G4FR时省了不少的功夫. 演示结果","categories":[],"tags":[{"name":"国民技术N32项目移植","slug":"国民技术N32项目移植","permalink":"https://rx-ted.github.io/blog/tags/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/"}]},{"title":"国民技术N32项目移植】基于SSD1306","slug":"国民技术N32项目移植】基于SSD1306&RTT的I2C example","date":"2023-03-04T14:53:20.000Z","updated":"2023-12-10T06:12:40.821Z","comments":true,"path":"/2023/03/04/国民技术N32项目移植】基于SSD1306&RTT的I2C example/","permalink":"https://rx-ted.github.io/blog/2023/03/04/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D%E3%80%91%E5%9F%BA%E4%BA%8ESSD1306&RTT%E7%9A%84I2C%20example/","excerpt":"","text":"ssd1306 examplertconfig.hcopy Previous file to this project, called rtconfig.h. add other functions, such as 12345#define RT_USING_I2C#define RT_USING_I2C2 //can choice RT_USING_I2C1 or RT_USING_I2C3#define RT_USING_RTC // update date, but this isn&#x27;t what is needed.#define RT_USING_SOFT_RTC // can&#x27;t need this//last two lines can be commented. SSD1306 IIC读写时序IIC读写时序 SSD1306 INIT初始化流程init初始化流程 usagessd1306 i2c 128X32Others developed the library, including I2C and SPI, But I simply delete the SPI functions, currently normal.I choice RT_USING_I2C, speed is set to 1000000(1000K). 1#define I2C2_SPEED 1000000 //It was 100K,now it&#x27;s 1000K library name url RTT_SSD1306 传送门 rtt-ssd1306怎么使用 RUN TEST运行测试视频","categories":[],"tags":[{"name":"国民技术N32项目移植","slug":"国民技术N32项目移植","permalink":"https://rx-ted.github.io/blog/tags/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/"}]},{"title":"【国民技术N32项目移植】ssd1306项目移植","slug":"【国民技术N32项目移植】ssd1306项目移植","date":"2023-03-04T14:53:08.000Z","updated":"2023-12-10T06:12:38.537Z","comments":true,"path":"/2023/03/04/【国民技术N32项目移植】ssd1306项目移植/","permalink":"https://rx-ted.github.io/blog/2023/03/04/%E3%80%90%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D%E3%80%91ssd1306%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/","excerpt":"","text":"【国民技术N32项目移植】ssd1306项目移植国民技术和RT-Thread合作，于是做了一个基于RT-Thread框架开发一个可视化界面，例如接口有GPIO、UART、I2C等等。 1.芯片资源 接口 描述 GPIO 点灯，熄灯 UART 串口，finsh I2C ssd1306可视化 … … GPIO怎么接点亮LED灯是GPIO的基础功能之一。如何让LED闪烁。 引脚 序号 描述 PB5 D3 点灯，熄灯 PA8 D1 点灯，熄灯 UART怎么接UART是默认选UART1，如何让单片机发送接收消息。 引脚 序号 描述 PA9 RXD 串口接收 PA10 TXD 串口发送 I2C怎么接I2C是默认选I2C1，如何让单片机连接SSD1306屏幕。 引脚 序号 描述 PB8 SCLK I2C时钟 PB9 SDA I2C读写数据 2.移植实操和过程总结 1、N32G4FR在RT-Thread上正常运行平台上可以选择VS CODE 或者是Keil5,我选择前者。需要的工具：vscodearm-eabi-none-gcc(大多数是C语言)EIDE烧录工具：pwlink、swd，等移植库包（SDK、Core，Example等等） 怎么搭建开发环境，传送门 总结：在过程中搭建环境或者移植中，遇到一些困难，只要认真解决，在群上多问问，多动脑子，多多动手编程，这样会发现原来是这样的，我怎么没想到~ 2、N32G4FR在finsh上正常运行 FinSH主要用于调试、查看系统信息，也支持敲代码，不再是只看而无法输入代码。用户在控制终端输入命令，控制终端通过通信协议的方式将命令传给N32G4FR FinSH，而FinSH会读取设备输入命令，解析并执行输出回应，将结果显示在控制终端上。本文以串口UART1作为FinSH的输入输出端口与 PC 进行通信，描述如何在 N32G4FR开发板上实现 FinSH shell 功能。在 RT-Thread Nano 上添加 FinSH 组件，实现FinSH功能需要开启路径：rt-thread&#x2F;components&#x2F;finsh,添加头文件路径和源文件。 3、N32G4FR在SSD1306上正常运行 SSD1306 IIC读写时序 SSD1306 INIT初始化流程 基于RT-Thread实现，OLED的I2C驱动都是自己修改，因为使用硬件IIC不能与库兼容起来，如果需要兼容则需要修改源码，目前已实现。其他人开发的库，包括I2C和SPI，但我只是删除了SPI函数，目前正常。我选择RT_USING_I2C，且设置I2C1，速率就默认好了。 在rtconfig.h上面编辑 copy Previous file to this project, called rtconfig.h. add other functions, such as ~~~~ 12345#define RT_USING_I2C#define RT_USING_I2C2 //can choice RT_USING_I2C1 or RT_USING_I2C3#define RT_USING_RTC // update date, but this isn&#x27;t what is needed.#define RT_USING_SOFT_RTC // can&#x27;t need this//last two lines can be commented. library name url RTT_SSD1306 传送门 rtt-ssd1306 API使用 3.作品代码与演示视频代码我上传代码，在github网址&#x2F;example&#x2F;02SSD1306，就是SSD1306开源地址，其他项目，欢迎浏览。传送门 RUN TEST 运行测试视频","categories":[],"tags":[{"name":"国民技术N32项目移植","slug":"国民技术N32项目移植","permalink":"https://rx-ted.github.io/blog/tags/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/"}]},{"title":"注册chat-gpt教程","slug":"注册chat-gpt教程","date":"2023-03-04T14:15:04.000Z","updated":"2023-12-10T06:12:41.113Z","comments":true,"path":"/2023/03/04/注册chat-gpt教程/","permalink":"https://rx-ted.github.io/blog/2023/03/04/%E6%B3%A8%E5%86%8Cchat-gpt%E6%95%99%E7%A8%8B/","excerpt":"ChatGPT 由人工智能公司 Open AI 推出，其对自己的定义是优化对话的语言模型，体验非常震撼，我提供一种注册方式。","text":"注册chat-gpt教程国外网络环境准备需要借助国外IP，才可以做下一步需要将网络环境切换国外ip，建议使用北美、日韩等IP. 注册 ChatGPT 账号并完成邮箱验证打开链接进行账号注册 完成这一步之后，下面就到了手机号验证的环节了。 这里需要尤其注意的是，不能是使用国内的手机号，因为 OpenAI 服务目前暂不支持国内，因此国内手机号是没有办法通过验证的。 另外 Google Voice 等北美地区的虚拟号码也是不能用的，因为 OpenAI会检测虚拟号码，他们也不允许虚拟号码注册。 这时候就要用到下一步的接码平台。 通过 sms-activate.org （短信接码平台）接收手机验证码完成验证大家可以通过接码平台完成手机号的验证，推荐平台链接地址：sms-activate.org 在这里需要注册一个 sms-activate 平台的账号，用邮箱注册就可以了。注册后通过邮箱完成验证。下一步是充值。选择支付宝，支付0.2美元即可 充值好了以后回到首页搜索「open」关键字就可以找到 OpenAI 验证码的临时号码购买链接。 邮箱登录，开始使用 ChatGPT直到上面一步整个注册流程就结束啦！ 注册完后，我们去 ChatGPT 网站去登陆：链接 下面就可以开始体验了，超强人工智能 AI ChatGPT 在等你哦！","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"https://rx-ted.github.io/blog/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"基于hexo框架借助github开发博客网站","slug":"基于hexo框架借助github开发博客网站","date":"2023-03-04T14:11:18.000Z","updated":"2023-12-10T06:12:40.921Z","comments":true,"path":"/2023/03/04/基于hexo框架借助github开发博客网站/","permalink":"https://rx-ted.github.io/blog/2023/03/04/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E5%80%9F%E5%8A%A9github%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"我为什么开发这个博客网站加强记忆，学习新技能，提升写作能力；记录生活，记录自己都日常；偶尔记录下每个不同人生阶段的感悟；分享给更多有共同兴趣爱好的小伙伴一起参与自己做的事。","text":"概述本文以hexo框架为基础，借助github pages的特点开发网站–博客首先感谢github、hexo和fluid的帮助。Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev负责开发与维护。主题教程 GitHub: 传送门预览网站： rx-ted’s blog|Fluid’s blog| zkqiang’s blog 我为什么开发这个博客网站 加强记忆，学习新技能，提升写作能力； 记录生活，记录自己都日常； 偶尔记录下每个不同人生阶段的感悟； 分享给更多有共同兴趣爱好的小伙伴一起参与自己做的事。 安装 nodejs git hexo-cli hexo init hexo-theme-fluid 注册github或者新建仓库 nodejs下载：node.js一般下载最新版本，向下兼容旧版本安装好了可以查看版本，如下命令： 1npm --version git下载：git网上下载对应版本即可，下载完后有2个，分别是git bash （命令行）和 git gui（桌面）随便选一个，敲代码，如下： 1git --version hexo-cli可以在新建博客默认路径，如下路径：D:\\blog (简称博客默认路径)打开博客默认路径，右击进入git bash，敲代码，如下： 123# 可以选择2种，我选第一种npm install -g hexo-cli # -g 代表全局保存，一般在%appdata%/npm/*npm install --save hexo-cli # 代表局部保存，一般在当前路径/npm下载路径/* hexo init1234567# 如果博客默认路径里面有内容，请删除内容cd D:\\bloghexo init# 等待一段时间，出现一些文件文件夹# 试试运行看看效果hexo server# 但不喜欢主题，怎么可以自主选择，我选的是Fluid主题 hexo-theme-fluid下载方法很多，由你选择 git clone1234# 语法： git clone --branch tag号码 git下载路径mkdir themescd themesgit clone --branch v1.9.4 https://github.com/fluid-dev/hexo-theme-fluid.git npm install1npm install --save hexo-theme-fluid 注册github或者新建仓库上网有很多教程，就不用我详细了。注册好了，进入仓库-setting-page，里面会看到用户名.github.io.仓库名 参数完成上述安装步骤，则可以修改一些参数 指定主题打开博客默认路径-_config.yml 12theme: fluidlanguage: zn-CN 设置网址打开博客默认路径-_config.yml 12345deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;project&gt; # example, https://github.com/hexojs/hexojs.github.io branch: gh-pages 全局覆盖主题复制themes&#x2F;hexo-theme-fluid&#x2F;_config.yml到博客默认路径&#x2F;_config.fluid.yml覆盖配置 详细配置需要你探索指导配置 上传网站发布版本123456789101112git clone 仓库网址# 下载好了，隐藏文件夹.git 把这个复制到博客默认路径# 发布rag标签# git tag 将要发布的新版本号git tag v1.0.0# 暂存git add .# 提交git commit -m &quot;输入描述&quot;# 推送git push origin v1.0.0# 就这样上传好了 博客生成12345678# 展示效果，先看看好不好hexo server# 清理hexo clean# 生成文章hexo g# 部署发布hexo d 博客展示部署好了，要等一段时间可以打开网站，如： https://github.com/hexojs/hexojs.github.io （就是你默认仓库网址）","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"https://rx-ted.github.io/blog/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"【python】录音","slug":"【python】录音","date":"2023-02-16T13:41:47.000Z","updated":"2023-12-10T06:12:38.441Z","comments":true,"path":"/2023/02/16/【python】录音/","permalink":"https://rx-ted.github.io/blog/2023/02/16/%E3%80%90python%E3%80%91%E5%BD%95%E9%9F%B3/","excerpt":"MASR致力于简单，实用的语音识别项目","text":"一、MASR是什么？MASR是一款基于Pytorch实现的自动语音识别框架，MASR全称是神奇的自动语音识别框架（Magical Automatic Speech Recognition），MASR致力于简单，实用的语音识别项目。本程序基于作者作品MASR简单录音并语音识别，感谢作者提供代码。 二、使用步骤在github 上 clone code:record.py其中MASR需要训练模型，需要很多时间，随你们折腾。若不想训练模型，则可以在MASR上下载模型。模型-&gt;下载 1.必要的条件 python3 ffmpeg (MASR需要用到) pytorch、wave、pyaudio、masr（pip install XXX） 2.引入库代码如下（示例）： 12345678910import waveimport timeimport osimport _threadimport pyaudioimport tkinterfrom masr.predict import Predictorimport torchdevice = torch.device(&quot;cpu&quot;) # 若有GPU，则修改GPUtk = tkinter.Tk() # 界面控件 2.Recording类 初始定义代码如下（示例）：12345678910111213141516171819202122def __init__(self, window: tk) -&gt; None: self.window = window self.window.title(&#x27;语音识别&#x27;) self.window.geometry(&#x27;300x300&#x27;) self.window.resizable(False, False) # 不能最大化 self.recordButton = tkinter.Button( self.window, text=&#x27;录音识别&#x27;, width=10, command=self.record_audio_thread,) self.recordButton.place(x=100, y=50) # 放置位置 self.showLabel = tkinter.Label(self.window, text=&quot;输出日志:&quot;) self.showLabel.place(x=10, y=80)# 放置位置 self.result_text = tkinter.Text( self.window, width=39, height=10, yscrollcommand=True) self.result_text.place(x=10, y=100)# 放置位置 # 录音功能 self.recordFlag = False # 控制说话标志 self.max_record = 600 # 600s 最大录音时长 self.output_path = &#x27;dataset/record&#x27; self.p = pyaudio.PyAudio() # 识别功能 self.predictor = Predictor(decoder=&#x27;ctc_greedy&#x27;,use_gpu=False) # 其余的参数都是默认的，不需要改动太大。ctc_greedy解码器，我在Windows上使用，其他系统没测试过，若有人测试过，则告知我，谢谢。 录音代码如下（示例）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def record_audio_thread(self): if not self.recordFlag: # 开始录音 self.result_text.insert(tkinter.END, &#x27;开始录音\\n&#x27;) _thread.start_new_thread(self.recordAudio, ()) # 新线程 else: self.result_text.insert(tkinter.END, &#x27;停止录音\\n&#x27;) self.recordButton.configure(text=&#x27;录音识别&#x27;) self.recordFlag = False # 停止录音#----------------------------------------------------------------def recordAudio(self): self.recordButton.configure(text=&#x27;停止录音&#x27;) self.recordFlag = True # 识别间隔时间 interval_time = 2 CHUNK = 16000 * interval_time format = pyaudio.paInt16 channels = 1 rate = 16000 # 打开录音 self.stream = self.p.open(format=format, channels=channels, rate=rate, input=True, frames_per_buffer=CHUNK) start = time.time() frames = [] while True: if not self.recordFlag: break data = self.stream.read(CHUNK) frames.append(data) # 超出最大录制时间 if len(frames) * 2 &gt; self.max_record: self.result_text.insert(tkinter.END, &quot;录音已超过最大限制时长,强制停止录音!&quot;) break # 保存录音 if not os.path.exists(self.output_path): os.makedirs(self.output_path) self.wav_path = os.path.join( self.output_path, &#x27;%s.wav&#x27; % str(int(time.time()))) wf = wave.open(self.wav_path, &#x27;wb&#x27;) wf.setnchannels(channels) wf.setsampwidth(self.p.get_sample_size(format)) wf.setframerate(rate) wf.writeframes(b&#x27;&#x27;.join(frames)) wf.close() self.recording = False self.result_text.insert( tkinter.END, &quot;录音已结束,录音文件保存在:%s\\n&quot; % self.wav_path) self.speechRecognition(self.wav_path) 语音识别代码如下（示例）：12345678def speechRecognition(self, wav_path): try: start = time.time() score, text = self.predictor.predict(audio_path=wav_path) self.result_text.insert(tkinter.END, &quot;消耗时间：%dms, 识别结果: %s, 得分: %d\\n&quot; % ( round((time.time() - start) * 1000), text, score)) except Exception as e: print(e) 这样就可以录音识别，不需要借助百度阿里语音识别识别，只是准确率有点低。 三、单纯使用录音功能代码如下（实例）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# -*- encoding:utf-8 -*-# author:rx-tedimport waveimport timeimport osimport _threadimport pyaudioimport tkinterclass Recording: def __init__(self, window: tk) -&gt; None: self.window = window self.window.title(&#x27;语音&#x27;) self.window.geometry(&#x27;300x300&#x27;) self.window.resizable(False, False) # 不能最大化 self.recordButton = tkinter.Button( self.window, text=&#x27;录音&#x27;, width=10, command=self.record_audio_thread,) self.recordButton.place(x=100, y=50) # 放置位置 self.showLabel = tkinter.Label(self.window, text=&quot;输出日志:&quot;) self.showLabel.place(x=10, y=80)# 放置位置 self.result_text = tkinter.Text( self.window, width=39, height=10, yscrollcommand=True) self.result_text.place(x=10, y=100)# 放置位置 # 录音功能 self.recordFlag = False # 控制说话标志 self.max_record = 600 # 600s 最大录音时长 self.output_path = &#x27;dataset/record&#x27; self.p = pyaudio.PyAudio() ## 识别功能 #self.predictor = Predictor(decoder=&#x27;ctc_greedy&#x27;,use_gpu=False) # 其余的参数都是默认的，不需要改动太大。 def record_audio_thread(self): if not self.recordFlag: # 开始录音 self.result_text.insert(tkinter.END, &#x27;开始录音\\n&#x27;) _thread.start_new_thread(self.recordAudio, ()) # 新线程 else: self.result_text.insert(tkinter.END, &#x27;停止录音\\n&#x27;) self.recordButton.configure(text=&#x27;录音&#x27;) self.recordFlag = False # 停止录音 # def speechRecognition(self, wav_path): # try: # start = time.time() # score, text = self.predictor.predict(audio_path=wav_path) # self.result_text.insert(tkinter.END, &quot;消耗时间：%dms, 识别结果: %s, 得分: %d\\n&quot; % ( # round((time.time() - start) * 1000), text, score)) # except Exception as e: # print(e) def recordAudio(self): self.recordButton.configure(text=&#x27;停止录音&#x27;) self.recordFlag = True # 识别间隔时间 interval_time = 2 CHUNK = 16000 * interval_time format = pyaudio.paInt16 channels = 1 rate = 16000 # 打开录音 self.stream = self.p.open(format=format, channels=channels, rate=rate, input=True, frames_per_buffer=CHUNK) start = time.time() frames = [] while True: if not self.recordFlag: break data = self.stream.read(CHUNK) frames.append(data) # 超出最大录制时间 if len(frames) * 2 &gt; self.max_record: self.result_text.insert(tkinter.END, &quot;录音已超过最大限制时长,强制停止录音!&quot;) break # 保存录音 if not os.path.exists(self.output_path): os.makedirs(self.output_path) self.wav_path = os.path.join( self.output_path, &#x27;%s.wav&#x27; % str(int(time.time()))) wf = wave.open(self.wav_path, &#x27;wb&#x27;) wf.setnchannels(channels) wf.setsampwidth(self.p.get_sample_size(format)) wf.setframerate(rate) wf.writeframes(b&#x27;&#x27;.join(frames)) wf.close() self.recording = False self.result_text.insert( tkinter.END, &quot;录音已结束,录音文件保存在:%s\\n&quot; % self.wav_path) # self.speechRecognition(self.wav_pathif __name__ == &#x27;__main__&#x27;: Recording(tk) tk.mainloop() 这个例子，简单录音，不具备识别语音。 总结我叫高敬义，笔名是rx-ted，高兴和大家认识，希望和大家一起成长，一起收获能量的共振，使人开心的想要原地起飞。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://rx-ted.github.io/blog/tags/Python/"}]},{"title":"【踩坑笔记】QtScrcpy利用tcp_ip把手机投影到电脑上","slug":"【踩坑笔记】QtScrcpy利用tcp-ip把手机投影到电脑上","date":"2023-02-16T13:38:55.000Z","updated":"2023-12-10T06:12:39.305Z","comments":true,"path":"/2023/02/16/【踩坑笔记】QtScrcpy利用tcp-ip把手机投影到电脑上/","permalink":"https://rx-ted.github.io/blog/2023/02/16/%E3%80%90%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0%E3%80%91QtScrcpy%E5%88%A9%E7%94%A8tcp-ip%E6%8A%8A%E6%89%8B%E6%9C%BA%E6%8A%95%E5%BD%B1%E5%88%B0%E7%94%B5%E8%84%91%E4%B8%8A/","excerpt":"利用tcp/ip把手机投影到电脑上，不需要数据线连接，利用同一个局限网，实现无线连接。","text":"目的：利用tcp&#x2F;ip把手机投影到电脑上，不需要数据线连接，利用同一个局限网，实现无线连接。我找了很多资料，还是选择QtScrcpy。其中原因有三： 第一，学习值得学的内容； 第二，如何编译使用，遇到困难如何解决； 第三，作为笔记。 QtScrcpy可以通过USB(或通过TCP&#x2F;IP)连接Android设备，并进行显示和控制。不需要root权限。同时支持GNU&#x2F;Linux，Windows和MacOS三大主流桌面平台。 具体内容，就不再描述了，传送门：中文 英文 接下来，如何下载、如何编译、如何使用。 准备准备什么，首先阅读作者的README.md,其中有说明安装过程，传送 1234567BuildAll the dependencies are provided and it is easy to compile.PC client1. Set up the Qt development environment on the target platform. Qt version&gt;=5.12 (use MSVC 2019 on Windows)2. Clone the project3. Open the project root directory all.pro or CMakeLists.txt with QtCreator4. Compile and run 上面描述，我们需要下载一些必备的依赖软件。 cmake &gt;&#x3D;3.19 Qt &gt;&#x3D; 5.12 MSVC 2019 及其以上 或者 MingW (我版本是:4.3.5) Visual Studio 或者 make 缺了一个，那就不行了。至于如何安装，就不讲了。 下载下载方式很多，能下载就OK。我选择git克隆方法，于是打开poewrshell这个命令行。如下代码： 按照我步骤去做，总算没错吧。 1234567cd d:\\mkdir toolscd toolsgit clone https://github.com/barry-ran/QtScrcpy.gitcd QtScrcpy\\QtScrcpymkdir build cd build 目前位置：d:\\tools\\QtScrcpy\\QtScrcpy\\build命令输出结果： 123456789101112131415PS D:\\&gt; cd toolsPS D:\\tools&gt; git clone https://github.com/barry-ran/QtScrcpy.gitCloning into &#x27;QtScrcpy&#x27;...remote: Enumerating objects: 5363, done.remote: Counting objects: 100% (579/579), done.remote: Compressing objects: 100% (291/291), done.remote: Total 5363 (delta 299), reused 460 (delta 273), pack-reused 4784Receiving objects: 100% (5363/5363), 403.14 MiB Receiving objects: 100% (5363/5363), 403.24 MiB | xx.00 MiB/s, done.Resolving deltas: 100% (3501/3501), done.Updating files: 100% (374/374), done.PS D:\\tools&gt; cd .\\QtScrcpy\\QtScrcpy\\PS D:\\tools\\QtScrcpy\\QtScrcpy&gt; mkdir buildPS D:\\tools\\QtScrcpy\\QtScrcpy&gt; cd buildPS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; 提示：下载过程中数据不时出现断开网络或者没反应的情况，换个方式下载吧。 编译编译时首先检查QT_DIR环境变量是否存在，若没有则设置如下代码: 12cmake -G &quot;MinGW Makefiles&quot; ..# 选择MingW编译器，利用cmake编译一下. 结果输出如下: 123456789101112131415161718PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; cmake -G &quot;MinGW Makefiles&quot; ..-- The CXX compiler identification is GNU 8.1.0-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: D:/XXXX/mingw/bin/g++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- [QtScrcpy] Project QtScrcpy 0.0.0-- [QtScrcpy] CPU_ARCH:x64-- [QtScrcpy] BUILD_TYPE:RelWithDebInfo-- [QtScrcpy] C++ compiler ID is: GNU-- [QtScrcpy] Set warnings as error-- [QtScrcpy] Qt version is: 5.12-- multi config:QC_IS_MUTIL_CONFIG-- Configuring done-- Generating done-- Build files have been written to: D:/tools/QtScrcpy/QtScrcpy/buildPS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; 这时候在D:\\tools\\QtScrcpy\\QtScrcpy\\build上出现几个文件，其中Makefile文件，则表示可以用make命令,如下代码: 1make make命令后会发现有些问题，错误结果是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; make[ 2%] Automatic MOC and UIC for target QtScrcpy[ 2%] Built target QtScrcpy_autogen[ 4%] Automatic RCC for res/res.qrcScanning dependencies of target QtScrcpy[ 7%] Building CXX object CMakeFiles/QtScrcpy.dir/QtScrcpy_autogen/mocs_compilation.cpp.obj[ 9%] Building CXX object CMakeFiles/QtScrcpy.dir/adb/adbprocess.cpp.obj[ 12%] Building CXX object CMakeFiles/QtScrcpy.dir/device/device.cpp.obj[ 14%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/controller.cpp.obj[ 17%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/inputconvert/inputconvertbase.cpp.obj[ 19%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/inputconvert/inputconvertnormal.cpp.obj[ 21%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/inputconvert/inputconvertgame.cpp.obj[ 24%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/inputconvert/controlmsg.cpp.obj[ 26%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/inputconvert/keymap/keymap.cpp.obj[ 29%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/receiver/devicemsg.cpp.obj[ 31%] Building CXX object CMakeFiles/QtScrcpy.dir/device/controller/receiver/receiver.cpp.obj[ 34%] Building CXX object CMakeFiles/QtScrcpy.dir/device/decoder/avframeconvert.cpp.obj[ 36%] Building CXX object CMakeFiles/QtScrcpy.dir/device/decoder/decoder.cpp.obj[ 39%] Building CXX object CMakeFiles/QtScrcpy.dir/device/decoder/fpscounter.cpp.obj[ 41%] Building CXX object CMakeFiles/QtScrcpy.dir/device/decoder/videobuffer.cpp.obj[ 43%] Building CXX object CMakeFiles/QtScrcpy.dir/device/filehandler/filehandler.cpp.obj[ 46%] Building CXX object CMakeFiles/QtScrcpy.dir/device/recorder/recorder.cpp.obj[ 48%] Building CXX object CMakeFiles/QtScrcpy.dir/device/render/qyuvopenglwidget.cpp.obj[ 51%] Building CXX object CMakeFiles/QtScrcpy.dir/device/server/server.cpp.obj[ 53%] Building CXX object CMakeFiles/QtScrcpy.dir/device/server/tcpserver.cpp.obj[ 56%] Building CXX object CMakeFiles/QtScrcpy.dir/device/server/videosocket.cpp.obj[ 58%] Building CXX object CMakeFiles/QtScrcpy.dir/device/stream/stream.cpp.obj[ 60%] Building CXX object CMakeFiles/QtScrcpy.dir/device/ui/toolform.cpp.obj[ 63%] Building CXX object CMakeFiles/QtScrcpy.dir/device/ui/videoform.cpp.obj[ 65%] Building CXX object CMakeFiles/QtScrcpy.dir/devicemanage/devicemanage.cpp.obj[ 68%] Building CXX object CMakeFiles/QtScrcpy.dir/fontawesome/iconhelper.cpp.obj[ 70%] Building CXX object CMakeFiles/QtScrcpy.dir/uibase/keepratiowidget.cpp.obj[ 73%] Building CXX object CMakeFiles/QtScrcpy.dir/uibase/magneticwidget.cpp.obj[ 75%] Building CXX object CMakeFiles/QtScrcpy.dir/util/config.cpp.obj[ 78%] Building CXX object CMakeFiles/QtScrcpy.dir/util/bufferutil.cpp.obj[ 80%] Building CXX object CMakeFiles/QtScrcpy.dir/util/mousetap/mousetap.cpp.obj[ 82%] Building CXX object CMakeFiles/QtScrcpy.dir/util/mousetap/winmousetap.cpp.obj[ 85%] Building CXX object CMakeFiles/QtScrcpy.dir/main.cpp.obj[ 87%] Building CXX object CMakeFiles/QtScrcpy.dir/dialog.cpp.obj[ 90%] Building RC object CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.objD:\\tools\\QtScrcpy\\QtScrcpy\\res\\QtScrcpy.rc:1:10: fatal error: winres.h: No such file or directory #include &quot;winres.h&quot; ^~~~~~~~~~compilation terminated.D:\\workers\\mingw\\bin\\windres.exe: preprocessing failed.make[2]: *** [CMakeFiles\\QtScrcpy.dir\\build.make:623: CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.obj] Error 1make[1]: *** [CMakeFiles\\Makefile2:83: CMakeFiles/QtScrcpy.dir/all] Error 2make: *** [makefile:90: all] Error 2PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; 请移步看下错误1的原因分析和解决方案。 做好了，接下来，如下命令: 1make 输出结果如下: 123456789PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; make[ 2%] Automatic MOC and UIC for target QtScrcpy[ 2%] Built target QtScrcpy_autogen[ 4%] Building RC object CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.objD:\\workers\\mingw\\bin\\windres.exe: D:\\\\tools\\\\QtScrcpy\\\\QtScrcpy\\\\res\\\\QtScrcpy.rc:25: syntax errormake[2]: *** [CMakeFiles\\QtScrcpy.dir\\build.make:623: CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.obj] Error 1make[1]: *** [CMakeFiles\\Makefile2:83: CMakeFiles/QtScrcpy.dir/all] Error 2make: *** [makefile:90: all] Error 2PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; 请移步看下错误2的原因分析和解决方案。 做好了，接下来，如下命令: 1make 输出结果如下: 123456789101112PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; make[ 2%] Automatic MOC and UIC for target QtScrcpy[ 2%] Built target QtScrcpy_autogenScanning dependencies of target QtScrcpy[ 4%] Building RC object CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.objD:\\tools\\QtScrcpy\\QtScrcpy\\res\\QtScrcpy.rc:5: warning: &quot;VERSION_RC_STR&quot; redefined #define VERSION_RC_STR &quot;rx-ted&quot;&lt;command-line&gt;: note: this is the location of the previous definition[ 7%] Building CXX object CMakeFiles/QtScrcpy.dir/QtScrcpy_autogen/PNK5WDWK6L/qrc_res.cpp.obj[ 9%] Linking CXX executable D:\\tools\\QtScrcpy\\output\\x64\\RelWithDebInfo\\QtScrcpy.exe[100%] Built target QtScrcpy 意味着成功了，定位到 D:\\tools\\QtScrcpy\\output\\x64\\RelWithDebInfo这个文件夹，并打开这个程序，是否运行成功。如下截图： 上面如何下载，编译，使用，我就讲完了。 不管遇到问题，学会思考，为什么会出现错误，尝试能不能独立解决这个问题，并总结一下，若时间允许的话，可以记笔记。 原因分析：错误112345678D:\\tools\\QtScrcpy\\QtScrcpy\\res\\QtScrcpy.rc:1:10: fatal error: winres.h: No such file or directory #include &quot;winres.h&quot; ^~~~~~~~~~compilation terminated.D:\\workers\\mingw\\bin\\windres.exe: preprocessing failed.make[2]: *** [CMakeFiles\\QtScrcpy.dir\\build.make:623: CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.obj] Error 1make[1]: *** [CMakeFiles\\Makefile2:83: CMakeFiles/QtScrcpy.dir/all] Error 2make: *** [makefile:90: all] Error 2 这个错误告诉我winres.h没有这个库，只要找到winres.h源代码，然后导入库，就行了。 错误212345678PS D:\\tools\\QtScrcpy\\QtScrcpy\\build&gt; make[ 2%] Automatic MOC and UIC for target QtScrcpy[ 2%] Built target QtScrcpy_autogen[ 4%] Building RC object CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.objD:\\workers\\mingw\\bin\\windres.exe: D:\\\\tools\\\\QtScrcpy\\\\QtScrcpy\\\\res\\\\QtScrcpy.rc:25: syntax errormake[2]: *** [CMakeFiles\\QtScrcpy.dir\\build.make:623: CMakeFiles/QtScrcpy.dir/res/QtScrcpy.rc.obj] Error 1make[1]: *** [CMakeFiles\\Makefile2:83: CMakeFiles/QtScrcpy.dir/all] Error 2make: *** [makefile:90: all] Error 2 这个是语法错误，要么注释，要么修改winres.h源代码。 解决方案：解决错误1D:\\tools\\QtScrcpy\\QtScrcpy\\res\\QtScrcpy.rc:1:10到这行就错了，说明附近没有winres.h,那么我们只要在D:\\tools\\QtScrcpy\\QtScrcpy\\res上新建winres.h就行了，如下代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// This is a part of the Microsoft Foundation Classes C++ library.// Copyright (C) 1992-1999 Microsoft Corporation// All rights reserved.//// This source code is only intended as a supplement to the// Microsoft Foundation Classes Reference and related// electronic documentation provided with the library.// See these sources for detailed information regarding the// Microsoft Foundation Classes product.// winres.h - Windows resource definitions// extracted from WINUSER.H and COMMCTRL.H#ifdef _AFX_MINREBUILD#pragma component(minrebuild, off)#endif#define VS_VERSION_INFO 1#ifdef APSTUDIO_INVOKED#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols#endif#ifndef WINVER#define WINVER 0x0400 // default to Windows Version 4.0#endif#include &lt;winresrc.h&gt;#ifdef _MAC#define DS_WINDOWSUI 0x8000L#endif// operation messages sent to DLGINIT#define LB_ADDSTRING (WM_USER+1)#define CB_ADDSTRING (WM_USER+3)#ifdef APSTUDIO_INVOKED#undef APSTUDIO_HIDDEN_SYMBOLS#endif#ifdef IDC_STATIC#undef IDC_STATIC#endif#define IDC_STATIC (-1)#ifdef _AFX_MINREBUILD#pragma component(minrebuild, on)#endif 解决错误2 D:\\tools\\QtScrcpy\\QtScrcpy\\res\\QtScrcpy.rc:25: syntax error 方法1 打开QtScrcpy.rc这个文件，然后注释一下。 1234567891011121314151617181920212223242526272829303132333435 #include &quot;winres.h&quot;IDI_ICON1 ICON &quot;QtScrcpy.ico&quot;// GB2312编码的话，在中文系统上打包FileDescription可以显示中文// 在github action（英文系统）打包后FileDescription是乱码，utf8编码也不行。。VS_VERSION_INFO VERSIONINFO FILEVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH PRODUCTVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH FILEFLAGSMASK 0x3fL#ifdef _DEBUG FILEFLAGS 0x1L#else FILEFLAGS 0x0L#endif FILEOS 0x40004L FILETYPE 0x1L FILESUBTYPE 0x0LBEGIN BLOCK &quot;StringFileInfo&quot; BEGIN BLOCK &quot;080404b0&quot; BEGIN VALUE &quot;CompanyName&quot;, &quot;RanKun&quot; VALUE &quot;FileDescription&quot;, &quot;Android real-time display control software&quot; // VALUE &quot;FileVersion&quot;, VERSION_RC_STR VALUE &quot;LegalCopyright&quot;, &quot;Copyright (C) RanKun 2018-2038. All rights reserved.&quot; VALUE &quot;ProductName&quot;, &quot;QtScrcpy&quot; // VALUE &quot;ProductVersion&quot;, VERSION_RC_STR END END BLOCK &quot;VarFileInfo&quot; BEGIN VALUE &quot;Translation&quot;, 0x804, 1200 ENDEND 方法2 知道VERSION_RC_STR没有被定义，我们只要重新定义就行了。打开QtScrcpy.rc这个文件，然后修改一下。 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;winres.h&quot;#define VERSION_RC_STR &quot;rx-ted&quot;IDI_ICON1 ICON &quot;QtScrcpy.ico&quot;// GB2312编码的话，在中文系统上打包FileDescription可以显示中文// 在github action（英文系统）打包后FileDescription是乱码，utf8编码也不行。。VS_VERSION_INFO VERSIONINFO FILEVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH PRODUCTVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_PATCH FILEFLAGSMASK 0x3fL#ifdef _DEBUG FILEFLAGS 0x1L#else FILEFLAGS 0x0L#endif FILEOS 0x40004L FILETYPE 0x1L FILESUBTYPE 0x0LBEGIN BLOCK &quot;StringFileInfo&quot; BEGIN BLOCK &quot;080404b0&quot; BEGIN VALUE &quot;CompanyName&quot;, &quot;RanKun&quot; VALUE &quot;FileDescription&quot;, &quot;Android real-time display control software&quot; VALUE &quot;FileVersion&quot;, VERSION_RC_STR VALUE &quot;LegalCopyright&quot;, &quot;Copyright (C) RanKun 2018-2038. All rights reserved.&quot; VALUE &quot;ProductName&quot;, &quot;QtScrcpy&quot; VALUE &quot;ProductVersion&quot;, VERSION_RC_STR END END BLOCK &quot;VarFileInfo&quot; BEGIN VALUE &quot;Translation&quot;, 0x804, 1200 ENDEND","categories":[],"tags":[{"name":"踩坑笔记","slug":"踩坑笔记","permalink":"https://rx-ted.github.io/blog/tags/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"}],"author":"rx-ted"},{"title":"【国民技术N32项目移植】基于Windows的ARMGCC开发环境","slug":"【国民技术N32项目移植】基于Windows的ARMGCC开发环境","date":"2023-02-16T12:59:51.000Z","updated":"2023-12-10T06:12:38.725Z","comments":true,"path":"/2023/02/16/【国民技术N32项目移植】基于Windows的ARMGCC开发环境/","permalink":"https://rx-ted.github.io/blog/2023/02/16/%E3%80%90%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D%E3%80%91%E5%9F%BA%E4%BA%8EWindows%E7%9A%84ARMGCC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"本文以 N32G4FR 系列 MCU 为例，介绍了在 Windows 环境下基于 vscode 编辑器、GCC 编译工具链和 GDB 调试工具进行搭建开发环境、编译、固件下载和代码调试的方法。","text":"【国民技术N32项目移植】基于 Windows 的 ARM GCC 开发环境 目录 基于 Windows 的 ARM GCC 开发环境 概述 开发工具 软件 硬件 开发环境搭建 安装 VScode 软件 安装 gcc 编译工具链 安装 make for Windows 安装 JLink 工具 目录详细说明 编译和下载 概述本文以 N32G4FR 系列 MCU 为例，介绍了在 Windows 环境下基于 vscode 编辑器、GCC 编译工具链和 GDB 调试工具进行搭建开发环境、编译、固件下载和代码调试的方法。 开发工具软件 编辑器 Visual Studio Code 编译工具链 arm-none-eabi-gcc Make for Windows 下载工具 调试工具 （略） 硬件 开发板 N32G4FR 一条数据线 开发环境搭建安装 VScode 软件下载软件：VScode 安装 gcc 编译工具链下载地址：gcc 安装 make for Windows下载地址：make 安装 JLink 工具略 目录详细说明├─build 生成文件├─doc 文档├─firmware 固件│ ├─CMSIS 系统如下│ │ ├─core 核心文件│ │ └─device 设备文件│ │ └─startup 启动文件│ ├─n32g4fr_algo_lib 算法库│ ├─n32g4fr_std_periph_driver 静态│ └─n32g4fr_usbfs_driver USB├─include 头文件├─note 随笔└─src 源代码 编译和下载在第一个目录下运行 1make 可以得到运行结果 12345678PS D:\\N32G4FR&gt; make arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=soft -Wall -Os -ffunction-sections -fdata-sections -g -gdwarf-2 -MMD -MP -MF&quot;build/delay.d&quot; -DN32G4fr -DUSE_STDPERIPH_DRIVER -Ifirmware/CMSIS/core/ -Ifirmware/CMSIS/device/ -Ifirmware/n32g4fr_std_periph_driver/inc/ -Ifirmware/n32g4fr_usbfs_driver/inc/ -Iinclude/ -Ifirmware/n32g4fr_algo_lib/inc/ -c -Wa,-a,-ad,-alms=build/delay.lst src/delay.c -o build/delay.o...arm-none-eabi-size build/output.elf text data bss dec hex filename 1516 1088 4904 7508 1d54 build/output.elfarm-none-eabi-objcopy -O ihex -S build/output.elf build/output.hexarm-none-eabi-objcopy -O binary -S build/output.elf build/output.bin 源代码下载传送门：rx-ted","categories":[],"tags":[{"name":"国民技术N32项目移植","slug":"国民技术N32项目移植","permalink":"https://rx-ted.github.io/blog/tags/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/"}],"author":"rx-ted"},{"title":"Hello hexo","slug":"hello-hexo","date":"2022-12-31T16:00:00.000Z","updated":"2023-12-10T06:12:39.941Z","comments":true,"path":"/2023/01/01/hello-hexo/","permalink":"https://rx-ted.github.io/blog/2023/01/01/hello-hexo/","excerpt":"hexo 快速用法","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://rx-ted.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[],"tags":[{"name":"IOT","slug":"IOT","permalink":"https://rx-ted.github.io/blog/tags/IOT/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://rx-ted.github.io/blog/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"rt-thread移植","slug":"rt-thread移植","permalink":"https://rx-ted.github.io/blog/tags/rt-thread%E7%A7%BB%E6%A4%8D/"},{"name":"前端","slug":"前端","permalink":"https://rx-ted.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"简历","slug":"简历","permalink":"https://rx-ted.github.io/blog/tags/%E7%AE%80%E5%8E%86/"},{"name":"国民技术N32项目移植","slug":"国民技术N32项目移植","permalink":"https://rx-ted.github.io/blog/tags/%E5%9B%BD%E6%B0%91%E6%8A%80%E6%9C%AFN32%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D/"},{"name":"经验","slug":"经验","permalink":"https://rx-ted.github.io/blog/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"Python","slug":"Python","permalink":"https://rx-ted.github.io/blog/tags/Python/"},{"name":"踩坑笔记","slug":"踩坑笔记","permalink":"https://rx-ted.github.io/blog/tags/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"}]}